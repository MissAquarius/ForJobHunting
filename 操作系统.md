# 绪论
* 冯诺曼机的结构“Von Neumann计算机”又称“存储程序式计算机” 
* 操作系统由控制器、运算器、存储器、输入装置、输出装置组成
* 操作系统的基本类型：批处理、多道、分时、实时

# 操作系统的结构和硬件支持
* 根据对资源和机器指令的使用权限，把处理机执行时的两种工作状态分为核态（核心态、管态、系统态）和用户态（目态）
  * 核态（Kernel Mode)，又称系统态：CPU执行管理程序时所处的状态。在此状态下允许CPU使用全部资源和全部指令，其中包括特权指令
  * 当CPU执行用户程序时，CPU处于用户态
* 中断：指某个事件 (例如电源断电、定点加法溢出或I/O传输结束等) 发生时，系统终止现行程序的运行、引出处理事件程序对该事件进行处理，处理完毕后返回断点，继续执行
  * 强迫性中断事件不是正在运行的程序所期待的，而是由于某种事故或外部请求所引起的，如：电源断电、溢出
  * 自愿性中断事件是正在运行的程序所期待的事件。这种事件是由于执行了一条访管指令而引起的，它表示正在运行的程序对操作系统有某种需求，一旦机器执行到一条访管指令时，便自愿停止现行程序而转入访管中断处理程序处理，如：要求操作系统启动外围设备工作
  
# 操作系统的用户接口
* 操作系统是用户与计算机之间的接口，操作系统为用户提供两种不同的接口：
  * 命令接口：由一组以不同形式表示的操作命令组成——键盘命令&图形命令:每个命令实现和完成用户所要求的特定功能和服务。
  * 程序接口（系统功能调用）

# 进程及进程管理（重点）
* 并发执行的条件：该条件在1966年首先由Bernstein提出，又称之为Bernstein条件假设，对于程序pi：
R(pi)={a1，a2，…，an}，表示程序pi在执行期间引用的变量集，即要读的变量集合；
W(pi)={b1，b2，…，bm}，表示程序pi在执行期间改变的变量集，即要写的变量集合；
若两个程序p1和p2能满足Bernstein条件：引用变量集(读与写)与改变变量集交集(写与写)之和为空集

* 进程和程序的区别：
  1. 程序是指令的集合，是静态的概念。进程是程序在处理机上的一次执行的过程，是动态的概念。程序可以作为软件资料长期保存。进程是有生命周期的。
  2、进程是一个独立的运行单位，能与其它进程并行（并发）活动。而程序则不是。
  3、进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。
  4、一个程序可以作为多个进程的运行程序，一个进程也可以运行多个程序。

* 进程的基本状态
[!image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png)
  1. 就绪：存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行，这些进程所取的状态为就绪状态。（可有多个进程处于此状态）
  2. 运行：当进程由调度/分派程序分派后，得到CPU控制权，它的程序正在运行，该进程所处的状态为运行状态。（在系统中，某一时刻，总是只有一个进程处于此状态，这也就是所谓的微观上串行。）
  3. 等待(阻塞)：若一个进程正在等待某个事件的发生（如等待I/O的完成），而暂停执行，这时，即使给它CPU，它也无法执行，则称该进程处于等待状态。

* 进程状态转换: 五状态进程模型
[!image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/%E4%BA%94%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png)
  1. 就绪—运行: 调度程序选择一个新的进程运行
  2. 运行—就绪:运行进程用完了时间片; 运行进程被中断，因为一个高优先级进程处于就绪状态
  3. 运行—等待:OS尚未完成服务(例如，系统功能调用); 对一资源的访问尚不能进行; 初始化I/O且必须等待结果; 等待某一进程提供输入
  4. 等待—就绪:当所等待的事件发生时/请求的服务已经完成
  进程的其他状态：
  1. 创建状态：创建一个新的进程
  2. 终止状态：完成任务，结束进程
  3. 挂起（suspend）状态：进程没有占用内存空间; 处在挂起状态的进程映像在磁盘上

* 进程之间的相互制约关系
  * 临界资源: 当两个进程公用一个变量时，它们必须顺序地使用，一个进程对公用变量操作完毕后，另一个进程才能去访问和修改这一变量。一次仅允许一个进程使用的资源称为临界资源。  
  * 临界区：在每个进程中，访问临界资源的那段程序能够从概念上分离出来，称为临界区或临界段。
  * 进程之间有两种关系：第一种是竞争关系，从而有进程的互斥是解决进程间竞争关系的手段; 第二种是协作关系，某些进程为完成同一任务需要分工协作。进程的同步是解决进程间协作关系的手段。
  * 互斥和同步：
    * 进程的互斥是指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其它要使用该资源的进程必须等待，直到占有资源的进程释放该资源; 进程的同步是解决进程间协作关系的手段。指一个进程的执行依赖于另一个进程的消息，当一个进程没有得到来自于另一个进程的消息时则等待，直到消息到达才被唤醒。
    * 解决进程互斥同步的方法: 1. 锁 ;     2. 信号量和P/V操作: 信号量 S>0：其数值代表可用的资源数量; S=0：代表无资源可用，但也没有等待的进程，即也没有申请资源的进程; S<0：其|S|表示等待队列中想申请资源而还没有成功的进程数量. P操作将消耗资源,将 s= s-1, 如果s>=0, 则该进程继续执行, 否则进程挂起; V操作释放资源, 将 s= s+1, 如果s > 0，转进程调度, 否则唤醒一个（或多个）等待该信号灯的进程. 对于互斥资源：P、V操作在同一个进程中; 对于共享资源的同步： P、V操作在不同进程中; 如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要，同步P操作在互斥P操作前; 而两个V操作的顺序无关紧要

  * 进程间通信方式：
  1. 共享内存：相互通信的进程间设有公共内存，一组进程向该公共内存中写，另一组进程从公共内存中读
  2. 消息传递：有时进程间可能需要交换更多的信息，例如，一个输入输出操作请求，要求把数据从一个进程传送给另一个进程，这种大量的信息传递可使用一种高级通信方式——消息传递来实现: 消息传递模式分为两大类：(a)消息缓冲（直接通信 ）; (b)信箱通信（间接通信）

* 线程与进程：
  * 进程作为资源的拥有者，在创建、撤消、切换的过程中，OS必须为之付出较大的时空开销。所以系统中进程的数量不宜过多，进程切换的频率不宜过高，但这也就限制了并发度的进一步提高
  * 引入进程的目的是为了使多个程序并发执行，以提高资源的利用率和系统的吞吐量;  引入线程则是为了减少程序并发执行时所付出的时空开销
  * 线程是进程中的一个实体，是被系统独立调度的基本单位. 线程自己基本不拥有系统资源，只拥有少量必不可少的私有资源：程序计数器、一组寄存器、栈.
线程可以与同属于一个进程的其它线程共享进程所拥有的全部资源. 一个线程可以创建和撤消另一个线程；同一进程中的多个线程之间可以并发执行, 系统开销小、切换快。
  * 进程与线程比较（重点！！！）
    1. 调度： 传统操作系统中，进程既是拥有资源的基本单位，又是独立调度的基本单位. 引入线程的操作系统中线程是独立调度的基本单位，进程是拥有资源的基本单位，从而可以显著地提高系统的并发度。
    2. 拥有资源： 进程是拥有资源的独立单位，它有权申请系统的各类资源。线程除了拥有很少的私有资源以外，不能申请系统资源，可以共享其所属进程的资源
    3. 系统开销：操作系统管理进程的开销显著地大于管理线程所需的开销。进程切换的开销也远大于线程切换的开销。由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信也比较容易。

* 进程调度：
  * 进程优先数调度算法: 按照某种原则由系统（或用户、或系统与用户结合）赋予每个进程一个优先数，在处理机空闲时，进程调度程序就从就绪进程中选择一个优先数最大的进程占用CPU（该进程就从就绪状态转换成运行状态）。
  * 循环轮转调度:循环轮转调度实际上是一种先来先服务的调度算法，它把系统的响应时间分成大小相等（或不相等）的时间单位，称为时间片。调度程序每次调度，总是从就绪队列队首移出一个进程，然后将此进程投入运行（由就绪状态转换成运行状态）。每个进程被调度到后，占用一个时间片，时间片用完后，该进程让出CPU，由运行状态转换成就绪状态，排在就绪队列的队尾。多个进程循环轮转。
  
# 资源分配与调度（重点）
* 进程死锁：每个进程都无限等待被该组进程中另一进程所占有的资源，因而无限期地僵持下去的局面，这种现象称为进程死锁

* 死锁的四个必要条件：
  1. 互斥条件（mutual exclusion）:任一时刻一个资源仅为一个进程独占，若另一个进程请求一个已被占用的资源时，它被置成等待状态，直到占用者释放资源。
  2. 占有和等待条件（hold and wait）:一个进程请求资源得不到满足而等待时，不释放已占有的资源。
  3. 不剥夺条件（no preemption）:任一进程不能从另一进程那里抢夺资源，即已被占用的资源，只能由占用进程自己来释放。
  4. 循环等待条件（circular wait）: 存在一个循环等待链，其中，每一个进程分别等待它前一个进程所持有的资源，造成永远等待
  
* 死锁的预防：
  1. 一次封锁法： 可以采用"静态资源分配的方式一次性的把所需资源全部分配到位，否则就不分配"; 资源分配图，打破环路
  2. 按序分配策略: 把系统的所有资源排列成一个顺序，必须按照这个顺序封锁
  3. 动态资源分配: 用银行家算法去防止系统进入不安全状态，从而避免死锁的发生（动态措施）. 
  安全状态：存在某种资源调度顺序，保证所有进程正常运行完成，则称该状态为安全状态。
  不安全状态：不存在可满足所有进程正常运行的资源调度顺序，则称该状态为不安全状态。当系统进入不安全状态后，便有可能进入死锁状态；只要系统处于安全状态，系统便可避免进入死锁状态。

* 银行家算法：
  1. 数据结构：现有资源向量Available、资源最大申请量矩阵Max、资源分配矩阵、需求矩阵Need
  2. 银行家算法是从当前状态出发，按照系统各类资源剩余量逐个检查各进程需要申请的资源量，找到一个各类资源申请量均小于等于系统剩余资源量的进程P1。然后分配给该P1进程所请求的资源，假定P1完成工作后归还其占有的所有资源，更新系统剩余资源状态并且移除进程列表中的P1，进而检查下一个能完成工作的客户，......。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。若找不到这样的安全序列，则当前状态不安全。

* 死锁的恢复
  * 撤消陷于死锁的全部进程；逐个撤消陷于死锁的进程，直到死锁不存在；从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。

# 内存管理

# 设备管理
* 缓冲： 两个设备传输速度不匹配时，实现平滑传输过程的手段。缓冲技术是用来匹配CPU与设备之间速度差异和负荷的不均匀。
* 外设和内存之间数据传送的控制方式分为4类：
  1. 程序直接控制方式: 用户进程来直接控制内存和外围设备之间的信息传送。
  2. 中断控制方式: 利用中断信号，外设可以将自身操作的状态及时反馈给CPU，这样，CPU便可以在发出一条I/O指令后，转去继续完成其他的任务。
  3. 直接存储器存取（DMA）方式: 在外设和主存之间开辟直接的数据交换通路。  
  4. 通道控制方式: 通道是一个独立于CPU的专管输入输出控制的处理机


# 文件系统
* DOS、WINDOWS系统中的文件名：文件名.[文件扩展名]; 在UNIX系统个字符的字符串。并且区分英文字母的大小写。中文件名就是一个字符串，没有文件名和文件扩展名之分，文件的类型由用户命名时确定。

* 文件的两种结构：
  (1) 逻辑记录: 逻辑记录是文件中按信息在逻辑上的独立含义来划分的信息单位。逻辑记录是对文件进行存取操作的基本单位。  
  (2) 物理记录: 在存储介质上，由连续信息所组成的一个区域称为块，也叫物理记录。 
      连续文件：它把一个逻辑上由连续记录构成的文件依次存放到连续的物理块中。优点：结构简单，实现容易，不需要额外的开销。如果知道文件在存储设备上的起始地址（第一个物理块号）和文件长度，就可以高速顺序地读取整个文件。缺点： 在建立文件时必须在文件说明中确定文件长度，且以后不能动态增长; 与内存的分区分配一样，存在碎片问题。<br>
      链接文件：链接文件逻辑上的连续性依靠每个物理块的最后一个存储单元中的链接指针来保证，前一块的指针指出后一块的地址(物理块号) ，最后一块的链接指针为空，第一块的地址(块号)由文件说明表的相应指针项指出。缺点存取速度慢 <br>
      索引文件：索引表的形式, 索引文件既适合于顺序访问，也适应于随机访问，是一种比较好的文件物理结构

* 文件存取管理：
  * 内存的分配是以字节为单位, 文件存储空间的分配是以物理块（512B）为单位。
  * 文件存储空间的管理实质上是一个空闲块（类似于内存管理中的空闲区）的组织和管理问题，包括空闲块的组织、分配与回收。 三种方法：空白文件目录、位示图、空白块链。
  
* 文件控制块FCB 是文件存在的标志，对每个文件都要设立一个文件控制块。

# 面试被问到的
* 资源调度方法：
  * 先来先服务FCFS：当一个进程就绪后，就将其加入就绪队列
  * 时间片轮转：以一个周期性间隔产生中断，当中断发生时，正在运行的程序就被置于就绪队列中，然后基于FCFS策略选择下一个就绪作业运行
  * 最短进程优先：每次都选择所需要时间最短的进程
  * 最短时间剩余
  * 最高响应比优先
  
