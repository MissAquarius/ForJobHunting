<!-- GFM-TOC -->
* <a href="#OSI七层模型">OSI七层模型</a>
* <a href="#数据链路层">物理层</a>
* <a href="#数据链路层">数据链路层</a>
* <a href="#网络层">网络层</a>
* <a href="#传输层">传输层</a>
* <a href="#应用层">应用层</a>
* <a href="#其他">其他</a>
<!-- GFM-TOC -->

# OSI七层模型
* 三种交换方式： 
  * 电路交换：整个报文的比特流连续地从源点直达终点。
  * 报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。
  * 分组交换(包交换)：使用存储转发技术，把要发送的报文分成几个分组，在分组的前面加上必要的控制信息（如源地址、目的地址等）。单个分组传送到相邻结点，存储下来后查找转发表，转发到下一个结点。

  报文：要发送的整块数据
  分组（包）：包头+数据部分，互联网传送的数据单元。
* 网络体系结构
  * 七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
  * 五层：物理层、数据链路层、网络层、传输层、应用层
  * 四层：

* 具体：
  1. 物理层： 为数据链路层提供物理连接，在其上串行传送比特流，即所传送数据的单位是比特。物理层使用的中间设备是转发器。
  2. 数据链路层： 定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 有 PPP、STP、CSMA/CD、交换机(二层)、网桥、适配器、ARP
  3. 网络层： 网络层负责在源机器和目标机器之间建立它们所使用的路由。IP、ICMP、ARP、路由器
  4. 传输层：建立、管理和维护端到端的连接，保证数据有效到达对端。TCP、UDP
  5. 会话层：负责在网络中的两节点之间建立、维持和终止通信。 功能：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。
  6. 表示层：数据格式转化和数据加密，是应用程序和网络之间的翻译官，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
  7. 应用层：为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 DNS、FTP、WWW、HTTP、SMTP、TELNET

# 物理层
* 考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，不是指具体的传输媒体。
* 所传送数据的单位是比特，使用的中间设备叫转发器
* 三种通信方式：
  * 单工：单向通信，只能有一个方向上的通信，如广播
  * 半双工：通信双方都可以发送消息，但是不能同时。
  * 全双工：通信双方可以同时发送和接受消息。

# 数据链路层
* 三个基本问题：
  * 封装成帧：把IP数据报的前后添加头部和尾部，表示帧的开始和结束
  * 透明传输：由于添加的帧开始和结尾的控制字符可能出现在数据报中，导致接收端接收错误，所以在数据包中用转义字符的形式。这样就可以传送任何数据了。
  * 差错检测：由于传送过程中会发生错误，如0变成1，所以采用CRC循环冗余检验，在数据报后面添加冗余码。
* 所传送数据的单位是帧，使用的中间设备叫网桥
* PPP协议

# 网路层
* 使用的中间设备叫路由器
* IP 协议是一种无连接的，不可靠的数据包协议，它并不能保证数据一定被送达
* 常用的协议：IP、地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP
* IP地址
  * IP地址：：={<网络号>, <主机号>}
  * 常用的三种类别的IP地址
    * A类：
    网络号占一个字节，网络号第一位固定为0，表示网络类别，所以可指派的网络号是2^7-2=126个，减去2是因为：全0的表示本网络(0)；全1的表示本地软件环回测试地址(127)
    主机号占三个字节，所以A类网络最大的主机数是:2^24-2，减去2是：主机号全0表示本主机所连接到的单个网络地址；主机号全1表示该网咯上的所有主机
    * B类：
    网络号占两个字节，网络号前两位固定为10，表示网络类别，所以可指派的网络号是2^14-1个，减去1是因为：最小地址128.0.0.0 不可指派
    主机号占两个字节，所以B类网络最大的主机数是:2^16-2，减去2是还是扣除主机位为全0和全1的
    * C类：
    网络号占三个字节，网络号前三位固定为110，表示网络类别，所以可指派的网络号是2^21-1个，减去1是因为：最小地址192.0.0.0 不可指派
    主机号占一个字节，所以B类网络最大的主机数是:2^8-2，减去2是还是扣除主机位为全0和全1的
  * 总结IP地址的指派范围：
  [!image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/IP%E5%9C%B0%E5%9D%80%E6%8C%87%E6%B4%BE%E8%8C%83%E5%9B%B4.png)

  * 重要特点
    * IP地址分等级，使得IP地址管理机构在分配IP地址时只分配网络号，而剩下的主机号由单位自行分配
    * 路由器仅根据目的主机所连接的网络号来转发分组，这样就减少了路由表中的项目数，所占存储空间和查找路由表的时间
    * 一个网络是指具有相同网络号net-id的主机集合，所以用转发器或者网桥连接起来的若干个局域网仍然属于一个网络，因为它们有相同的网络号；而路由器连接的是不同net-id的网络
    * 当一个主机同时连到两个网络上时，就必须同时有俩IP地址，其网络号必须是不同的，比如路由器
    * 网桥连接起来的网段仍然是一个局域网，只有一个网络号，它工作在数据链路层； 路由器总是有两个及以上的IP地址，工作在网络层。

* 硬件地址(MAC地址)与IP地址的区别
 * 从层次的角度看，物理地址是数据链路层和物理层使用的地址；而IP地址是网络层及以上使用的地址
 * 在发送数据时，数据从高层往下，IP数据报中使用的是IP地址，一旦到数据链路层，就会被加上头部和尾部封装成MAC帧。MAC帧在传送时，使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在首部。
 * IP地址在IP数据报的首部；MAC地址在MAC帧的首部

* 地址解析协议ARP
  * 解决同一个局域网上，主机或者路由器的 IP地址和MAC地址的映射问题
  * 在主机ARP高速缓存中存放一个从IP地址到硬件地址的动态更新的映射表
  * 同一个局域网上，主机A向主机B发送IP数据报时，首先在ARP高速缓存中查看有无B的IP地址，有的话就直接查出来；没有的话，ARP进程在本局域网内广播发送一个ARP包(我的IP地址是x.x.x.x，硬件地址是y-y-y-y-y-y，要IP地址为B的主机的硬件地址）。本局域网上的所有主机都可以收到此请求分组，只有主机B的IP地址与请求包中的地址一致，就收下这个请求分组，并向主机A发送响应分组，在响应分组中注明自己的MAC地址。主机A收到后，就将B的IP地址和MAC地址的映射关系写入到缓存中。
  * ARP请求分组是广播，而响应分组是普通的单播
  * 高速缓存中的每一个映射地址项目都有生存时间，超过生存时间的就从中删除

* 既然最终是用MAC地址通信，为啥还要抽象中IP地址呢？
因为对于异构网络来说，使用不同的硬件地址，要使异构网络之间通信，就需要非常复杂的硬件地址转换工作，但是使用统一的IP地址就可以解决这个复杂问题； IP 地址具有路由的功能

* IP数据报的格式
首部+数据部分， 首部包括固定部分（20字节）和可变部分（0-40字节）。首部有使用的IP版本号、首部长度、生存时间（跳数TTL）、首部校验和、源地址和目的地址
* 子网划分：
防止IP地址利用率低，从主机位中借用若干位作为subnet-id；子网掩码与IP地址按位与就能得到网络地址

* ICMP网际控制报文协议
  * 允许主机或路由器报告差错情况和提供有关异常情况的报告，包括ICMP差错报告报文和ICMP询问报文
  * 应用：
  PING命令测试主机之间的连通性，使用了ICMP回送请求和回送回答报文。应用层PING命令直接利用网络层的ICMP，没有通过传输层。通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率
  Unix系统中的Traceroute，用来跟踪一个分组从源点到终点的路径，原理就是数据报中封装的是无法交付的UDP用户数据报，每一次将TTL加1，第一次TTL=1，到第一个路由器后TTL-1=0，丢弃并向源主机发送ICMP超时的差错报文，之后类推。最后一个，因为无法交付，所以回复重点不可达的差错报告报文。


# 传输层
* 为主机中相互通信的应用进程提供端到端的逻辑通信，复用和分用（发送方的不同应用进程可以使用同一个传输层协议发送数据；接收方的传输层在剥去报文的首部后能够把这些数据正确交付目的应用进程）。所以两个进程要通信，不仅要知道对方的IP地址（找到主机），还需要知道端口号（找到进程）。
* 如何标志进程？ 操作系统中采用的是进程描述符来标志，但是不同系统的格式不一样，所以不可以使用PCB，而且进程的创建和撤销都是动态的，所以利用目的主机提供的功能来识别终点，而不需要知道实现该功能的进程是哪一个。端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。一个进程可以使用多个端口，但是一个端口不能被多个不同的进程绑定。端口号只具有本地意义，只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。

* 两种不同的传输协议：面向连接的TCP 和 无连接的UDP区别：（重要！！）
  * TCP 发送数据前需要建立连接； UDP 不需要
  * TCP 更可靠、稳定，但是效率较低，有延时，占用系统资源高； UDP 传输速度快，但不可靠、不稳定，可能丢包
    对网络通信质量有要求，数据准确时用 TCP，如浏览器、邮箱等； 不高、要求快用 UDP，如 QQ语音、视频
  * TCP 面向字节流，UDP 面向报文：
    TCP 把应用层传下来的报文看做字节流，有窗口大小限制，太长的话会被拆分进行发送；
    UDP 对应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部，无论交给 UDP 多长的报文都会一次性发送。
  * 每一条 TCP 连接只能是点对点的（一对一），不提供广播或者多播服务；而 UDP 支持一对一、一对多、多对一和多对多的交互通信。
  
* 用户数据报协议UDP特点
  * 无连接: 发送数据前后不需要建立和拆除连接，因此减少了开销和发送数据之前的时延
  * 不保证可靠交付：尽最大努力交付
  * 面向报文：发送方的UDP对应用程序交付下来的报文，在添加首部后就向下交付给IP层，不合并也不拆分，一次发送一个报文；接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就交付给上层的应用程序。因此，应用程序要选择合适的长度，过长的话，IP层需要分片；过短的话，会使IP数据报的首部相对长度太长，降低IP层的效率。
  * 没有拥塞控制：网络出现拥塞，不会使源主机的发送效率降低
  * 支持一对一、一对多、多对一、多对多的交互通信
  * UDP的首部开销小，只有8个字节，而TCP是20个字节
* UDP的首部包括：源端口、目的端口、长度、校验和（IP数据报的首部校验和只校验首部，而UDP是把首部和数据部分一起校验）

* 传输控制协议TCP的特点
  * 面向连接：应用程序在使用TCP协议之前必须先建立连接，传送数据完毕后，必须释放连接
  * 一对一通信：每一条TCP连接只能有两个端点，点对点通信
  * 可靠交付：无差错、不丢失、不重复、按顺序到达
  * 全双工通信：TCP连接的两端有发送缓存和接受缓存，允许通信中的双方任何时候都可以发送数据
  * 面向字节流：TCP把应用程序交付下来的数据看成是无结构的字节流，TCP不关心应用进程一次把多长的报文发送到缓存中，而是根据对方给出的接收窗口的大小和当前网络的拥塞情况来决定报文的长度

* 面试题： UDP 如何实现可靠连接
  UDP 在传输层无法保证数据的可靠传输，可以在应用层实现一些保证可靠传输的机制；
  最简单的方法： 在应用层模拟 TCP 的可靠性传输：
  1. 添加应答确认 seq/ack 机制，确保数据发送到对端；
  2. 添加发送和接收缓冲区，实现用户超时重传；
  3. 添加超时重传机制
  目前有如下开源程序利用udp实现了可靠的数据传输, 分别为RUDP、RTP、UDT

* 停止等待协议：
  * 每发送完一个分组就停止发送，等待对方的确认，收到确认后再发下一个分组
  * 超时重传：A发送完一个分组后，设定一个超时计时器，如果在计时器到期之前收到了对方的确认，就撤销计时器；如果没有，就重发分组。因此，A发送完一个分组后，必须先保留分组的副本，等收到确认后再清除；分组和确认分组必须进行编号（为什么？为了处理重复帧）；超时计时器设置的时间应该稍长于分组传输的平均往返时间。
  * 确认的分组丢失或者迟到：
    * A向B发送一个分组，B返回的确认分组丢失；超时后A又向B重新发送分组，此时B根据序号判断之前已经收到过，所以丢弃重复的分组，重传确认分组
    * A向B发送一个分组，未收到B的确认分组；超时后A又向B重新发送分组，收到了确认分组；过一会儿，最开始的确认分组到A，A根据序号判断这是一个迟到的确认分组，丢弃
  * 该协议简单，但是信道利用率太低，为了提高信道利用率，可以采用流水线传输，即发送方一次可发送多个分组，不必每发完一个分组就停顿下来等待对方的确认，这样就有了连续ARQ(自动重传请求)和滑动窗口的协议。
* 连续ARQ：
  发送方维持一个发送窗口，位于发送窗口内的分组都可以连续发送出去，而不需要等待对方的确认。每收到一个确认，就把发送窗口向前滑动一个分组的位置；接收方使用累计确认，不必每个都确认，对按序达到的最后一个分组发送确认。

* TCP可靠传输的保证
  * 以字节为单位的滑动窗口
    * 发送窗口：在没有收到确认的情况下，可以连续把窗口内的数据都发送出去；已经发送的数据在没有收到确认前必须暂时保留，以便在超时重传时使用（区分与发送缓存：存放应用程序传送给发送方TCP要发送的数据和已发送但尚未确认的数据）
    * 接收窗口：表示接收方可以接受的数据大小，只对按序收到的数据中的最高序号给出确认（接收缓存：存放未按序到达的数据和已经按序到达但尚未被接收方应用程序读取的数据）
  * 超时重传时间的选择：
    自适应算法，记录一个报文发出去到收到确认的时间，时间差就是报文段的往返时间，TCP保留了一个加权平均往返时间
  * 选择确认SACK
    解决收到的报文无差错，但是未按序，中间缺少了一些序号的数据，想要发送方只重传缺少的。需要在TCP首部加上允许sack，用的不多。

* TCP 流量控制（重点！！）
  * 流量控制：让发送方的发送速率不要太快，要让接收方来得及接收，利用滑动窗口实现
  * 发送方的发送窗口不能超过接收方给出的接收窗口的数值，当接收方的接收窗口是0的时候，为了防止死锁，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，到期就发送零窗口探测报文段，如果窗口还是零，重新计时；不是的话，对方在确认这个探测报文的时候就给出了新的窗口大小。

* TCP 拥塞控制（重点！！）
  * 拥塞控制与流量控制的区别： 拥塞控制是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。是一个全局性的过程，涉及到所有的主机、路由器、以及降低网络传输性能有关的所有因素。  流量控制 指点对点的通信量的控制，是个端到端的问题（接收端控制发送端），流量控制就是抑制发送端发送数据的速率，以便接收端来得及接收。
  * 四种拥塞控制算法：
  发送方维持一个拥塞窗口，大小取决于网络的拥塞程度，并且在动态变化。发送方的发送窗口取得是拥塞窗口和接收窗口的最小值。
    * 慢开始 
    开始发送数据前，先探测一下，即由小到大的逐渐增大拥塞窗口数值，通常在最开始的时候将cwnd值设置为一个最大报文段MSS的数值，然后收到确认后，把窗口值增多至多一个MSS的值。每经过一个传输轮次，拥塞窗口值就加倍。
    * 拥塞避免
    思路是让拥塞窗口cwnd的值缓慢增大，即每经过一个传输轮次，cwd加1，而不是加倍，这样按照线性规律缓慢增长，比慢开始算法的增长速率要慢。

    无论是在慢开始还是在拥塞避免阶段，只要发送方判断网络出现了拥塞，就把慢开始门限ssthresh 设置为出现拥塞时，发送方窗口值的一半，把拥塞窗口cwnd重新设置为1，执行慢开始算法，这样可以迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。

    慢开始门限ssthresh用法如下：
    当cwnd < ssthresh 时，采用慢开始算法；
    当cwnd = ssthresh 时，均可；
    当cwnd > ssthresh 时，采用拥塞避免算法；
    [!image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpg)

    * 快重传
    接收方每收到一个失序的报文段后就立即发出重复确认，为了使发送方及早知道有报文段没有到达对方。
    比如： 接收方收到了M1和M2两个报文，但是没有收到M3却收到了M4/M5/M6， 接收方就及时发送对M2的重复确认。发送方一连收到3个重复确认，就立即重传对方尚未收到的M2，而不必计时器到期。
     [!image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg)

    * 快恢复
    配合快重传，当发送方连续接收到三个重复确认时，就把慢开始门限减半，但是接下里并不开始执行慢开始算法，而是认为当前网络可能没有发生严重的拥塞，因此将拥塞窗口cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法。
     [!image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/%E5%BF%AB%E6%81%A2%E5%A4%8D.jpg)

* TCP建立连接与拆除连接
  * 套接字socket = (IP地址：端口号)，是TCP连接的端点
  * 具体过程见[这里](https://github.com/MissAquarius/ForJobHunting/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.md)

* 使用 TCP 和 UDP 的协议
  * TCP 对应的协议：FTP 文件传输协议、TELNET 用于远程登陆的端口、SMTP 邮件传输协议、HTTP
  * UDP 对应的协议：DNS、SNMP 简单网络管理协议、TFTP 简单文件传输协议、多播中的IGMP网际组管理雪域

# 应用层
* DNS域名解析：域名解析成IP地址；mail.qq.com (mail 是三级域名； qq是二级域名； com是顶级域名)
* HTTP见[这里](https://github.com/MissAquarius/ForJobHunting/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/HTTP%E7%9B%B8%E5%85%B3.md)

# 其他
* 集线器：物理层； 网桥、交换式集线器/第二层交换机：数据链路层；  路由器：网络层

## 扩充：OSI七层模型中对应的协议（面试常问某个协议是属于哪一层？）
层次     | 功能     |  主要协议  
---------- | :----------- | :-----------
 应用层     | 文件传输，电子邮件，文件服务，虚拟终端  |HTTP，FTP，DNS，SMTP，Telnet 等   
 表示层     | 数据格式化，代码转换，数据加密   | 没有协议
 会话层     | 接触与建立与别的接点的联系  | 没有协议  
 传输层     | 提供端对端的借口    | TCP，UDP
 网络层     | 为数据包选择路由 | IP，ICMP，OSPF，RIP等
 数据链路层  | 传输有地址的帧以及错误检测功能 | PPP，ARP等
 物理层     | 以二进制数据形式在物理媒体上传输数据 | ISO2110，IEEE802等 