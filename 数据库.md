
<!-- GFM-TOC -->
* <a href="#SQL语法">SQL语法</a>
* <a href="#事务">事务</a>
* <a href="#封锁">封锁</a>
* <a href="#存储过程">存储过程</a>
* <a href="#游标">游标和触发器</a>
* <a href="#范式">范式</a>
* <a href="#视图">视图</a>
* <a href="#索引">索引</a>
* <a href="#SQL约束">SQL约束</a>
* <a href="#MYSQL存储引擎">MYSQL存储引擎</a>
* <a href="#其他概念性东西">其他概念性东西</a>
* <a href="#SQL注入">SQL注入</a>
* <a href="#不同数据库的区别（常被问MySQL、MongoDB和Redis）">不同数据库的区别（常被问MySQL、MongoDB和Redis）</a>
* <a href="#参考资料">参考资料</a>
<!-- GFM-TOC -->

# SQL语法：
![image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/SQl%E8%AF%AD%E5%8F%A5%E4%BD%8E%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9.png)
* 数据定义语言DDL：
  * 建表CREATE，创建约束:
  ```sql
  -- 创建学生表，定义主键
  create table student(
	      sno char(20) primary key,
       	sname char(20) not null,
       	ssex int(2),
	      sgae smallint,
	      sdept char(20) );
  ```
  如果主键是两个字段的组合，应该把 PRIMARY KEY(col1, col2) 放最下面  <br>
  CREATE DATABASE database_name -- 创建数据库  <br>
  CREATE TABLE newtable AS SELECT * FROM mytable; -- 将一个表中的内容插入到一个新表  <br>
  * 修改表 ALTER
  ```sql
  ALTER TABLE table_name ADD column_name datatype; -- 数据库增加一列
  ALTER TABLE table_name DROP COLUMN column_name; -- 数据库删除一列
  ALTER TABLE table_name DROP UNIQUE(column_name); -- 删除列必须取唯一值的约束
  ALTER TABLE table_name MODIFY column_name datatype; -- 修改表字段的类型
  ```  
  * 删除表
  ```sql
  DROP TABLE students
  ```
  
* 数据操纵语言DML:  
  学生-课程数据库 student(sno, sname, ssex, sage, sdept) course(cno, cname) sc(sno, cno, grade)
  * SELECT
  ```sql
  -- 给定一个学生表，查出名字一样的学生数目（人数>=2）
  SELECT sname, COUNT(sanme) FROM students GROUP BY sname HAVING COUNT(sname) >= 2
  
  -- 找出每个科目的平均分，平均分大于90的科目
  SELECT cno, AVG(grade) FROM studens GROUP BY cno HAVING AVG(grade) > 90

  -- 选出平均分前 10 名的学生名单
  SELECT * FROM student WHERE sno in (
	SELECT sno FROM sc GROUP BY sno ORDER BY AVG(grade) DESC LIMIT 10)
	
  -- limit用法 :limit a,b  从a+1开始，往后数b条
  select * from  student limit 14, 6 -- 显示[15, 20]条
  select * from student limit 0, 5 -- 从第 1 条开始，显示 5 条，也就是显示前五条
  select * from student limit 5 -- 和上面等价
  
  -- 查找第二个字母是 E 或 O 或 I 的人名
  SLECT sname FROM students WHERE sname LIKE '_[EOI]%'   -- 如果选不是这些开头用 [^EOI]

  -- 查询以 “DB_” 开头，且倒数第 3 个字符为 i 的课程的详细信息
  SELECT * FROM course WHERE cname LIKE 'DB\_%i__' ESCAPE '\'   -- 添加转义  
  ```
  * INSERT
  ```sql
  INSERT INTO mytable(col1, col2) VALUES(val1, val2) -- 普通插入
  INSERT INTO mytable1(col1, col2) SELECT col1, col2 FROM mytable2; -- 插入检索数据
  ```
  * UPDATE
  ```sql
  UPDATE mytable SET col = val WHERE id = 1;
  ```
  * DELETE
  ```sql
  DELETE FROM mytable WHERE id = 1;
  ```
  
* 数据控制语言DCL
  ```sql
  -将查询 student 表和修改学生学号的权限授给用户 u1，并允许他将此权限授予其他用户
  GRANT SELECT, UPDATE(sno) ON TABLE student TO u1 WITH GRANT OPTION  -
  
  -- 将创建表的权限授予用户 u2
  GRANT CREATETAB ON DATABASE TO u2
  
  -- 收回所有用户对 student 表的插入权限
  REVOKE INSERT ON TABLE student FROM public
  
# 事务
* 定义：用户定义的一组操作序列，这些操作要么全做，要么全都不做。
* 特性：ACID
  * 原子性（Atomicity）：事务包含的所有操作要么全部成功，要么全部失败回滚
  * 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态
  * 隔离性（Isolation）：事务与事务之间的执行，互不干扰
  * 持久性（Durability）：一个事务一旦被提交了，则对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作
* 语法：
  * BEGIN TRAN transaction_name 
  * COMMIT TRAN transaction_name
  * ROLLBACK TRAN transaction_name
  * SAVEPOINT savepoint_name：在事务内部创建一系列可以 ROLLBACK 的还原点，这些还原点只能在事务内部创建
  * RELEASE SAVEPOINT savepoint_name：删除创建的保存点
  
# 封锁
* 事务在并发下，带来的数据不一致问题：
  * 丢失修改：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改丢失；
  * 不可重复读：指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果；
  * 读脏数据：一个事务读到另一个事务未提交的数据，后来另一个事务回滚，那第一个事务读到的就是脏数据
  * 幻读：在一个事务内读取到了别的输入插入的数据，导致第二次读取时与第一次相比，多了几行
  
* 解决不一致问题的方法——封锁：
  * 定义：事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象；
  * 锁类型：
    * 排它锁（x锁），又称写锁：若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A ，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。
    * 共享锁 (S锁），又称读锁：若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A ，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁
    * 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作： 在查询完数据的时候就把事务锁起来，直到提交事务；实现方式：使用数据库中的锁机制
    * 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性：在修改数据的时候把事务锁起来，通过version的方式来进行锁定; 实现方式：使用version版本或者时间戳

* 数据库的隔离级别（重点！）
  * read_uncommited(读未提交):所有事务都可以看到其他未提交事务的执行结果, 会有脏读
  （如： A事务读数据，在过程中，B事务对该数据的任何修改，A都是可以看到的）

  * read_commited(读已提交):这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）;一个事务只能看见已经提交事务所做的改变, 可以防止脏读
  （如： A事务读数据，在过程中，B事务对该数据的任何修改，只要没有提交，A都看不到，B事务提交之后，A 可以看到）

  * repeatable_read(可重复读): MYSQL的默认隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，可以防止脏读和不可重复读
  （如： A事务读数据，在过程中，B事务对该数据的任何修改，无论其提交与否，A都看不到；只有 A 事务也提交了才可以看到）

  * serilizable	(序列化读):这是最高的隔离级别,它通过强制事务排序，使之不可能相互冲突, 能解决事务并发操作脏读、不可重复读和幻读的问题
   （如： A事务要往表中插入数据，还没提交；此时B事务也想插数据，就会被拒绝）

* 保证数据一致性的协议——三级封锁协议
  * 一级封锁协议： 事务 T 在修改数据之前，必须对其加 X 锁，直到事务结束才释放（包括commit和rollback）--可以防丢失修改，保证事务是可恢复的
  * 二级封锁协议：在1级的基础上，加上：事务 T 在读取数据之前，必须对其加 S 锁，读完就释放  --可以防止 丢失修改 + 读脏数据
  * 三级封锁协议：在1级的基础上，加上：事务 T 在读取数据之前，必须对其加 S 锁，直到事务结束才释放 -- 可以防止 丢失修改 + 读脏数据 + 不可重复读
  
* 并行序列可串行化的协议————两段锁协议：
  * 并行序列可串行化：如果一个调度的结果与某一串行调度执行的结果等价，则称该调度是可串行化调度，否则是不可串调度。
  * 两段锁协议是保证并行事务可串化的方法：所有的事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一个阶段是获得封锁（扩张阶段）：事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是释放封锁（收缩阶段），事务可以释放任何数据项上的任何类型的锁，但不能申请。
  
* 活锁与死锁：
 * 活锁：当一系列封锁不按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁；解决方法是：先来先服务
 * 死锁：两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。产生的必要条件：互斥/占有并等待/不剥夺/环路等待；解决方法：预防（破坏产生死锁的必要条件）/诊断（检测是否有死锁产生）/解除（撤销掉代价最小的事务，解除环路） 
 
# 存储过程
* 定义：在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
* 优点：
  * 存储过程可以重复使用，减小开发人员的负担； 
  * 对于网络上的服务器，可减小网络流量，因为只需要传递存储过程的名称即可； 
  * 可以防止对表的直接访问，只需要赋予用户存储过程的访问权限
* 缺点：
  * 移植性差：依赖于数据库厂商,难以移植(当一个小系统发展到大系统时,对数据库的要求也会发生改变)；
  * 难以调试、维护：业务逻辑大的时候,封装性不够,难调试难以维护；
  * 服务器不能负载均衡。复杂的应用用存储过程来实现，就把业务处理的负担压在数据库服务器上了。没有办法通过中间层来灵活分担负载和压力.均衡负载等。

# 游标和触发器
* 游标 cursor：在存储过程中使用游标可以对一个结果集进行移动遍历。游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。
* 触发器： 在 INSERT、UPDATE、DELETE 执行的时候自动执行。 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中：CREATE TRIGGER mytrigger AFTER INSERT ON mytable ...触发器内容...

# 范式
* 不符合范式的关系，会产生很多异常，主要有以下四种异常：冗余数据、修改异常、删除异常、插入异常
* 范式越高，数据的冗余度越小。没有冗余的数据库设计是可以做到的，但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据
* 范式级别：实际应用，到3NF或者BCNF就可以了
  * 1NF：属性不可再分
  * 2NF：消除非主属性对码的部分函数依赖
  * 3NF：消除非主属性对码的传递函数依赖
  * BCNF：消除主属性之间的函数依赖
  * 4NF：消除表中的多值依赖
  * 5NF：消除不是由候选码所蕴含的连接依赖
* 当时学数据库的时候，在知乎上看明白的一篇[文章](https://www.zhihu.com/question/24696366)，介绍的很清楚

# 视图
* 概念：是从一个或几个基本表(或视图)中导出的表，是一个虚表，数据库中只存放视图的定义，而不存放视图的对应的数据。由于本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。
* 优点：
  * 简化复杂的 SQL 操作，比如将复杂的多表连接定义成视图，那么表与表之间的连接对用户隐藏，用户看到的是虚表，而不需要了解这个虚表是怎么来的；
  * 对重构数据库提供了一定程度上的逻辑独立性：数据库重构造时，如增加新的字段或者关系，可以定义新的视图，用户应用程序不受影响。
  * 用户能以多种角度看待同一数据，更灵活
  * 保证数据的安全性：对不同的用户定义不同的视图，用户只能看到自己权限内的数据
* 缺点：
  * 性能差：对视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，sql server也要把它变成一个复杂的结合体，需要花费一定的时间。 
  * 修改限制：当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于比较复杂的视图，可能是不可修改的。
* SQL语法
```sql
-- 建立信息系学生的视图，要求在修改和插入操作时仍需要保证该视图只有信息系的学生
CREATE VIEW is_dept AS SELECT * FROM students WHERE dept = 'IS' WITH CHECK OPTION

--查询信息系年龄小于20的学生
SELECT * FROM is_dept WHERE sage < 20

-- 更新同基本表
-- 删除视图
DROP VIEW is_dept
```

# 索引
* 面试题：建立索引的目的：
  * 唯一性索引，保证数据库中数据的唯一性
  * 加快数据检索速度
  * 加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
  * 在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。
  * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
* 创建索引不利的地方：
  * 创建索引和维护索引需要消耗时间
  * 索引需要占物理空间，如果要建立聚簇索引，那么需要额外空间会更大
  * 当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
* 什么列上需要建立索引？
  * 列为主键，强制该列的唯一性
  * 经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
  * 经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
  * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
  * 在经常使用在where子句中的列上面创建索引，加快条件的判断速度
* 面试题：什么列上不需要建立索引？
  * 不经常使用的列
  * 只有很少数据值的列（比如性别）
  * 对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
  * 经常需要修改的列
* 语法：
  * 单列索引：CREATE INDEX index_name ON table_name (column_name);
  * 唯一索引：CREATE UNIQUE INDEX index_name ON table_name (column_name);  特殊的： 主键索引（不可为空）
  * 聚簇索引：CREATE INDEX index_name ON table_name (column1, column2);
  * 隐式索引：隐式索引由数据库服务器在创建某些对象的时候自动生成。例如，对于主键约束和唯一约束，数据库服务器就会自动创建索引。
  * 删除索引：DROP INDEX index_name
* 面试题：数据库索引类型有哪些？

* 聚集索引与非聚集索引区别：
  * 聚集索引：索引的排列顺序和表中记录的排列顺序一致，查询快，修改慢
  * 非聚集索引（如字典中按照偏旁查字）：非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构
  * 根本区别：索引与表记录的顺序是否排列一致

* 唯一索引和主键索引：
  * 唯一索引： 保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用，允许有空值，使用 UNIQUE 来创建 
  * 主键索引： 就是主键，是一种特殊的唯一索引，不能为空。一张表中只能定义一个主键索引，通常有一列或列组合，用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。为表定义一个主键将自动创建主键索引（聚簇索引）。主键可以是聚簇索引也可以是非聚簇索引
  区别：
  1. 主键索引一定是唯一索引，唯一索引不一定是主键索引
  2. 唯一索引可以为空，主键索引不能为空
  3. 一张表只能有一个主键索引，可以有多个唯一索引

* 索引失效的情况
  1. 如果条件中有 or，即使其中有部分条件带索引也不会使用。 要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引。
  2. like 查询是以 % 开头，索引失效；但以 % 结尾，索引可以使用
  3. 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
  4. 对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。
  5. where 子句里对索引列上有数学运算，用不上索引
  6. where 子句里对有索引列使用函数，用不上索引， where abs(id)=1
  7. 如果 mysql 估计使用全表扫描要比使用索引快,则不使用索引，比如数据量极小的表

* 最左匹配原则(结合底层实现来理解)
  是针对联合索引来说的，一般把排序分组频率最高的列放在最左边，以最左边的为起点任何连续的索引都能匹配上，同时遇到范围查询(>、<、between、like)就会停止匹配。

  如果在一个表的三列，col1，col2，col3 建立了一个联合索引，在 select 语句中：
  1. where col1，where col1 and col2， where col1 and col2 and col3，可以命中索引
  2. where col2，where col3，不会命中索引
  3. where col1 and col3，能够命中部分索引，也就是 col1 这部分
  4. where col2 and col1，先会拿 col2 去比较，没有结果，但是 mysql 会对这个语句进行优化，把 col1 放在第一位，因此可以命中索引
  5.  where col1 > 1 and col3,  col1字段可以匹配上索引，但col3值不可以，因为col1的值是一个范围，在这个范围中col3是无序的

* 面试题： 索引的实现原理：
索引的本质是一种优化查询的数据结构，比如 Mysql 中的索引是用 B+ 树实现的，而 B+ 树就是一种能够优化查询速度的数据结构

能够优化查询速度的数据结构： B 树、 B+ 树、 哈希表、 平衡二叉树等

1. 为什么不用哈希表？
哈希表：key-value的形式，可以快速的精确查询，但是不支持范围查询。
2. 为什么不用平衡二叉树？
考虑到磁盘 IO 的影响，它相对于内存来说是很慢的。
数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。
3. 为什么不用B树
* B 树的优点：一个节点可以存储多个元素，所以整棵树的高度就降低了，磁盘IO效率提高了。
* B+ 树是 B 树的升级版，在B+树中，所有记录节点存放在叶子节点上，且是顺序存放，由各叶子节点指针进行连接，如果从最左边的叶子节点开始顺序遍历，能得到所有键值的顺序排序，提高范围查找的效率。

* B+树的磁盘读写代价更低：B+树的所有非叶子节点只会存放索引信息，而真正的数据信息都只存放在叶子节点中，这样一来，每个非叶子节点存放的索引信息就更多，一次磁盘IO就可以读取更多的索引信息到内存中，可以减少磁盘IO的次数。
* B+树的查询效率更加稳定：由于非叶子节点只存索引信息，而没有真正的数据信息，所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
* B+树更加适合在区间查询的情况，由于B+树的数据都存储在叶子结点中，非叶子结点均为索引，只需要扫一遍叶子结点即可得到所有数据信息，但是B树因为其非叶子结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。


# SQL约束
* NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
* UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
* PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
* FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
* CHECK: 用于控制字段的值范围。

# MYSQL存储引擎
* Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
  是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

Innodb引擎的索引的数据结构是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。

* MyIASM引擎(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键，设计简单，数据以紧密格式存储。
提供了大量的特性，包括压缩表、空间数据索引等。不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

MyIASM 引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。

* MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。

同一个数据库可以使用多种存储引擎的表。如果一个表修改要求比较高的事务处理，UPDATE DELETE 密集用 InnoDB。SELECT 密集用 MyISAM 存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。

* InnoDB 和 MyISAM 的区别
  1. 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
  2. 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
  3. 外键：InnoDB 支持外键。
  4. 备份：InnoDB 支持在线热备份。
  5. 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
  6. 其它特性：MyISAM 支持压缩表和空间数据索引。

# 其他概念性质的东西
* 关系型数据库和非关系型数据库的区别
  * 关系型数据库：
    * 最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织，关系型数据库有： oracle、DB2、SQL Server、Access、MySQL
    * 优点： 1. 易于维护：都是使用表结构，格式一致； 2.使用方便：SQL语言通用，可用于复杂查询；3.复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。
    * 缺点：1. 读写性能比较差，尤其是海量数据的高效率读写； 2.固定的表结构，灵活度稍欠；3. 高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。
  * 非关系型数据库：
    * 严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。非关系型数据库有： Hbase、MongodDB、Redis
    * 优点：1. 格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。2. 速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；3.高扩展性；成本低：nosql数据库部署简单，基本都是开源软件。
    * 缺点：1.不提供sql支持，学习和使用成本较高； 2.无事务处理； 3.数据结构相对复杂，复杂查询方面稍欠。
    
* drop/delete/truncate区别及适用场景
  * drop table/database/view: 1)属于DDL 2)不可回滚 3)不可带where 4)表内容和结构以及建立在表上的索引、触发器等全部删除 5)删除速度快 6)将表所占的空间释放掉 7)所有的DML都不会触发触发器
  * truncate table : 1)属于DDL 2)不可回滚 3)不可带where 4)表结构在，内容删除 5)删除速度快  6)表和索引空间恢复到初始大小
  * delete table/view: 1)属于DML 2)可回滚 3)可带where 4)表结构在，表内容要看where执行的情况 5)删除速度慢,需要逐行删除  6)表和索引所占空间不变 7)会触发触发器
  * 不再需要一张表的时候，用drop; 保留表而删除所有数据的时候用truncate; 想删除部分数据行时候，用delete，并且带上where子句
  
* SQL语句中 where 和 having 有什么区别
  * 用的地方不同： where 可以用于 select、update、delete 和 insert into values(select * from table where...) 中 having 只能用于 select 中，且跟在 group by 后面
  * 执行顺序不同： where 的搜索条件是在执行语句进入分组之前应用,  having 的搜索条件是在分组之后应用，和 where 一起的话，where 会先执行
  * 子句有区别： where 后面不能直接用聚合函数，通过子查询可以; having 后面可以直接用聚合函数 sum count min max avg
  
* 接上，为什么where后面不能用聚合函数？
  * sql 的执行顺序是： from -> where -> group by -> having -> order by -> select 
  * 聚集函数也叫列函数，它们都是基于整列数据进行计算的，而where子句则是对数据行进行过滤的。首先执行的是where子句，筛选出符合条件的集合，然后才能在集合上作分组以及列的运算。
  * 例子：查询分数大于平均分的学生信息
  ```sql
  SELECT * FROM students WHERE score > (SELECT AVG(score) FROM students)  -- 正确写法
  SELECT * FROM students WHERE score > AVG(score)   -- 错误写法
  ```
* count(* )和 count(字段) 的区别
  count(* ) 是统计结果集的总条数; count(字段) 是统计结果集中某字段不为 NULL 的总条数

* 连接
  * 内连接: 只得到两个表相匹配的行
  * 外连接
    * 左外连接：保留左表中的所有数据，如果左表的某行在右表中没有匹配行, 把不匹配的行的对应字段设为 NULL
    * 右外连接：保留右表中的所有数据，如果右表的某行在左表中没有匹配行, 把不匹配的行的对应字段设为 NULL
    * 全外连接: 左右表都不加限制

* MYSQL查询优化
  * mysql查询过程：
    1. 客户端向MySQL服务器发送一条查询请求
    2. 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
    3. 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
    4. MySQL根据执行计划，调用存储引擎的API来执行查询
    5. 将结果返回给客户端，同时缓存查询结果
  * 使用EXPLAIN进行分析：
    EXPLAIN 用来分析 SELECT 查询语句，根据结果来优化查询语句。 直接在 SELECT 之前加上 EXPLAIN 即可。 EXPLAIN 可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题
  * 优化数据访问：
    1. 减少访问量：
       只返回必要的列：最好不要使用 SELECT * 语句。 <br>
       只返回必要的行：使用 LIMIT 语句来限制返回的数据。<br>
       缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。<br>
     2. 减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。
   * 切分大查询：分解大连接查询 成 对每一个表进行一次单表查询，然后在应用程序中进行关联，用关键词 IN
   * 分库分表： 照一定的规则，对原有的数据库和表进行拆分，把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。 
     1. 垂直切分：垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。
     2. 水平切分: 表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出 0-4 个值；针对不同的hashID将数据存入不同的表中

* E-R图
  * 实体： 方框； 属性： 菱形； 联系：一对一、一对多、多对多

# SQL注入
* 概念： sql 注入是一种常见的网络攻击方式，是通过构建特殊的输入作为参数传入 web 应用程序，输入大多是 sql 语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作。本质：把用户输入数据作为代码执行。
* 原因：程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。
* 常见的 sql 注入：在登陆时输入框中填入 or 1=1 之类的内容，或者后面加 -- 注释掉不执行
* 预防：
  核心原则： 数据代码分离
  * 预编译语句，绑定变量。使用预编译的SQL语句，内置了处理SQL注入的能力，执行阶段只是把输入串作为普通数据处理。
  * 使用正则表达式过滤传入的参数、转义、检查数据类型
  * 使用存储过程： 存储过程是在大型数据库系统中，一组为了完成特定功能或经常使用的SQL语句集。存储过程可避免SQL注入，但也可能会存在注入问题，因此应该尽量避免在存储过程中使用动态的SQL语句。
 * 开发者角度：使用安全函数

# 数据库备份
热备份： 是系统处于正常运转状态下，采用 archivelog mode 方式备份数据库的方法。
冷备份： 也叫离线备份，是在关闭数据库并且数据库不能更新的状况下进行的数据库完整备份，可对数据进行指定恢复。


# 不同数据库的区别（常被问MySQL、MongoDB和Redis）

|     | MySQL | MongoDB | Redis |
| :------: | :------: | :------: | :------: |
| 类型 | 关系型数据库 | 文档型数据库 | 内存数据库 |
| 存储方式 | 根据引擎存储 | Bson | 内存+持久化文件 |
| 事务 | 支持 | 不支持 | 支持(弱) |
| 扩展性 | 比较固定，差 | 很灵活，可任意扩展 | 很灵活，可任意扩展 |
| CAP | 弱C弱A | 强C弱A | 弱C强A |
| 查询效率 | 超过100W，极慢 | 快 | 快++ |
| 分布式 | Mycat，复杂 | 可自行简单部署 | 可自行简单部署 |
| 适用场景 | 复杂关系的数据模型 | 弱关系，大量数据存储访问 | 较小数据量，大性能和运算 |
| 优点 | 二维表理解简单；SQL使用方便；丰富的完整性| 无需sql层的解析，读写快；基于bson存储，扩展性强 | 支持多种数据结构，支持持久化操作，单线程不需要考虑数据一致性问题 |
| 缺点 | 读写性能较差;固定的表结构;海量数据读写效率低 | 不提供sql支持,join效率低;无事务处理 | 只能使用单线程,性能受限于CPU性能;不具备自动容错和恢复功能;受内存限制 |



# 参考资料
* [数据库总结](https://juejin.im/post/5a9ca0d6518825555c1d1acd)
* [数据库隔离级别的实例演示](https://blog.csdn.net/zxh476771756/article/details/78687146)
