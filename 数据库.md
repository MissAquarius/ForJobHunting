
<!-- GFM-TOC -->
* <a href="#SQL语法">SQL语法</a>
* <a href="#事务">事务</a>
* <a href="#存储过程">存储过程</a>
* <a href="#游标">游标</a>
* <a href="#范式">范式</a>
* <a href="#视图">视图</a>
* <a href="#索引">索引</a>
* <a href="#锁">锁</a>
* <a href="#键">键</a>
* <a href="#SQL约束">SQL约束</a>
* <a href="#MYSQL存储引擎">MYSQL存储引擎</a>
* <a href="#不同数据库的区别">不同数据库的区别</a>
* <a href="#参考资料">参考资料</a>
<!-- GFM-TOC -->

# SQL语法：
![image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/SQl%E8%AF%AD%E5%8F%A5%E4%BD%8E%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9.png)
* 数据定义语言DDL：
  * 建表CREATE，创建约束:
  ```sql
  -- 创建学生表，定义主键
  create table student(
	       sno char(20) primary key,
       	sname char(20) not null,
       	ssex int(2),
	       sgae smallint,
	       sdept char(20)
        );
  ```
  如果主键是两个字段的组合，应该把 PRIMARY KEY(col1, col2) 放最下面  <br>
  CREATE DATABASE database_name -- 创建数据库  <br>
  CREATE TABLE newtable AS SELECT * FROM mytable; -- 将一个表中的内容插入到一个新表  <br>
  
  * 修改表 ALTER
  ```sql
  ALTER TABLE table_name ADD column_name datatype; -- 数据库增加一列
  ALTER TABLE table_name DROP COLUMN column_name; -- 数据库删除一列
  ALTER TABLE table_name DROP UNIQUE(column_name); -- 删除列必须取唯一值的约束
  ALTER TABLE table_name ALTER COLUMN column_name datatype; -- 修改表字段的类型
  ```
  
  * 建立索引
  ```sql
  CREATE [UNIQUE] [CLUSTERED] INDEX my_index ON student(sno)
  ```
  * mysql 如何限制表的大小只有两行
  ```sql
  CREATE TABLE student(id char(20)) ENGINE=InnoDB MAX_ROWS=2 -- 设置一个 MAX_ROWS 约束 
  ```
# 事务
* 定义：一个Session中所有进行的操作，要么全做，要么全都不做。
* 特性：ACID
  * 原子性（Atomicity）：事务包含的所有操作要么全部成功，要么全部失败回滚
  * 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态
  * 隔离性（Isolation）：事务与事务之间的执行，互不干扰
  * 持久性（Durability）：一个事务一旦被提交了，则对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作
* 语法：
  * BEGIN TRAN transaction_name 
  * COMMIT TRAN transaction_name
  * ROLLBACK TRAN transaction_name
  * SAVEPOINT savepoint_name：在事务内部创建一系列可以 ROLLBACK 的还原点，这些还原点只能在事务内部创建
  * RELEASE SAVEPOINT savepoint_name：删除创建的保存点
  
# 存储过程
  * 定义：在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
  * 优点：
    * 存储过程可以重复使用，减小开发人员的负担； 
    * 对于网络上的服务器，可减小网络流量，因为只需要传递存储过程的名称即可； 
    * 可以防止对表的直接访问，只需要赋予用户存储过程的访问权限
  * 缺点：
    * 
# 游标

# 范式
* 不符合范式的关系，会产生很多异常，主要有以下四种异常：冗余数据、修改异常、删除异常、插入异常
* 范式越高，数据的冗余度越小。没有冗余的数据库设计是可以做到的，但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据
* 范式级别：实际应用，到3NF或者BCNF就可以了
  * 1NF：属性不可再分
  * 2NF：消除非主属性对码的部分函数依赖
  * 3NF：消除非主属性对码的传递函数依赖
  * BCNF：消除主属性之间的函数依赖
  * 4NF：消除表中的多值依赖
  * 5NF：消除不是由候选码所蕴含的连接依赖
* 当时学数据库的时候，在知乎上看明白的一篇[文章](https://www.zhihu.com/question/24696366)，介绍的很清楚

# 视图

# 索引
* 建立索引的目的：
  * 唯一性索引，保证数据库中数据的唯一性
  * 加快数据检索速度
  * 加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
  * 在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。
  * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
* 创建索引不利的地方：
  * 创建索引和维护索引需要消耗时间
  * 索引需要占物理空间，如果要建立聚簇索引，那么需要额外空间会更大
  * 当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
* 什么列上需要建立索引？
  * 列为主键，强制该列的唯一性
  * 经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
  * 经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
  * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
  * 在经常使用在where子句中的列上面创建索引，加快条件的判断速度
* 什么列上不需要建立索引？
  * 不经常使用的列
  * 只有很少数据值的列（比如性别）
  * 对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
  * 经常需要修改的列
* 语法：
  * 单列索引：CREATE INDEX index_name ON table_name (column_name);
  * 唯一索引：CREATE UNIQUE INDEX index_name ON table_name (column_name);
  * 聚簇索引：CREATE INDEX index_name ON table_name (column1, column2);
  * 隐式索引：隐式索引由数据库服务器在创建某些对象的时候自动生成。例如，对于主键约束和唯一约束，数据库服务器就会自动创建索引。
  * 删除索引：DROP INDEX index_name
* 聚集索引与非聚集索引区别：
  * 聚集索引：索引的排列顺序和表中记录的排列顺序一致，查询快，修改慢
  * 非聚集索引（如字典中按照偏旁查字）：非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构
  * 根本区别：索引与表记录的顺序是否排列一致

# 封锁
* 并发操作带来的数据不一致问题：
  * 丢失修改：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改丢失；
  * 不可重复读：指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果；
  * 读脏数据：指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据为“脏”数据;
* 解决不一致问题的方法——封锁：
  * 定义：事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象；
  * 类型：
    * 排它锁（x锁），又称写锁：若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A ，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。
    * 共享锁 (S锁），又称读锁：若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A ，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁
 * 活锁与死锁：
   * 活锁：当一系列封锁不按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁；解决方法是：先来先服务
   * 死锁：两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。产生的必要条件：互斥/占有并等待/不剥夺/环路等待；解决方法：预防（破坏产生死锁的必要条件）/诊断（检测是否有死锁产生）/解除（撤销掉代价最小的事务，解除环路） 
 * 两段锁协议：
  * 并行序列可串行化：如果一个调度的结果与某一串行调度执行的结果等价，则称该调度是可串行化调度，否则是不可串调度。
  * 两段锁协议是保证并行事务可串化的方法：所有的事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一个阶段是获得封锁（扩张阶段）：事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是释放封锁（收缩阶段），事务可以释放任何数据项上的任何类型的锁，但不能申请。

# SQL约束

# MYSQL存储引擎
* InnoDB

* MyISAM
* MEMORY

# 其他概念性质的东西
* 关系型数据库和非关系型数据库的区别
  * 关系型数据库：
    * 最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织，关系型数据库有： oracle、DB2、SQL Server、Access、MySQL
    * 优点： 1. 易于维护：都是使用表结构，格式一致； 2.使用方便：SQL语言通用，可用于复杂查询；3.复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。
    * 缺点：1. 读写性能比较差，尤其是海量数据的高效率读写； 2.固定的表结构，灵活度稍欠；3. 高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。
  * 非关系型数据库：
    * 严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。非关系型数据库有： Hbase、MongodDB、Redis
    * 优点：1. 格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。2. 速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；3.高扩展性；成本低：nosql数据库部署简单，基本都是开源软件。
    * 缺点：1.不提供sql支持，学习和使用成本较高； 2.无事务处理； 3.数据结构相对复杂，复杂查询方面稍欠。
    
* E-R图
  * 实体： 方框； 属性： 菱形； 联系：一对一、一对多、多对多
# 不同数据库的区别（常被问MySQL、MongoDB和Redis）
  * 


# [参考资料](https://juejin.im/post/5a9ca0d6518825555c1d1acd)
