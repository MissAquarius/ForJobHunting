# 动态规划
把原问题分解为相对简单的子问题的方式，求解复杂问题。常用于求最优子结构性质的问题以及有重叠子问题。

## 基本思想
求解原问题，需要解不同的部分（子问题），再合并子问题的解得出原问题的解。通常子问题非常相似，所以dp方法识图解决子问题一次，从而减少计算量。
一旦一个子问题已经算出，则将其存储，等下次需要同一个子问题求解时，直接查表。

## 问题特征
* 最优子结构：问题的最优解包含子问题的最优解
* 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。

## 分治法与动态规划算法不同
* 相同点：二者都是讲原问题分解成若干个规模比较小的子问题求解，然后将子问题的解合并，形成原问题的解
* 不同点：分治法分解的子问题是相互独立的,常用递归解决；而动态规划分解后的子问题之间互相有联系，有重叠部分，需要存储每个子问题的解，常用迭代解决

## 斐波那契数列(可以不用数组保存值，为了节省空间，可用常量保存需要的两个值即可)
* [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/):
  ```python
  class Solution(object):        
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:  # 第一个台阶，有一种上法
            return 1
        if n == 2:  # 第二个台阶，有两种上法
            return 2
        
        # 从第三个台阶开始，每个台阶的可以从其倒数第一个台阶（上一步）和倒数第二个台阶（上两步）解法加和。用a和b分别表示这两种情况，并不断更新a和b值
        a = 1
        b = 2
        for i in range(n-2):
            res = a + b
            a = b
            b = res
        return res
  ```
  状态转移方程：dp[i] = dp[i-1] + dp[i-2]
  
* [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)
  ```python
  class Solution(object):
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        # 到达第i层的cost是不需要加上cost[i]的
        dp = [0, 0]  # 存储到达每一层的cost，初始时，到达第0层需要0，到达第1层需要0
        
        # 从第2层开始计算，直到顶部，即：第len(cost)层
        for i in range(2, len(cost)+1):
            dp.append(min(cost[i-1]+ dp[i-1], cost[i-2]+ dp[i-2]))
            
        return dp[-1]
  ```
  状态转移方程：dp[i] = max(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    
* [198. House Robber](https://leetcode.com/problems/house-robber/description/)
  ```python
  class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        # dp存储到第i户的最大抢劫数目：该值等于max（第i-1户，第i-2户+当前户），初始是存储第0户和第1户
        dp  = [0, nums[0]]
        for i in range(2, size+1):
            dp.append(max(dp[i-1], dp[i-2]+nums[i-1]))
        
        return max(dp[size], dp[size-1])
  ```
  状态转移方程：dp[i] = max(dp[i-1] , dp[i-2] + value[i])
  
* [213. House Robber II](https://leetcode.com/problems/house-robber-ii/description/)
  ```python
  class Solution(object): 
    def rob_house(self, nums):
        size = len(nums)
        
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        pre_2, pre_1 = 0, nums[0]
        
        for i in range(2, size+1):
            cur = max(pre_1, pre_2+nums[i-1])
            pre_2 = pre_1
            pre_1 = cur
        
        return max(cur, pre_1)
        
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 与上一题类似，只不过这里变成环形，可以求去掉第一个元素和去掉最后一个元素，然后二者取最大值
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        # nums长度大于2时，开始掐头去尾的比较
        return max(self.rob_house(nums[:-1]), self.rob_house(nums[1:]))
        
  ```
  
## 背包问题：0-1背包、完全背包、二维费用背包
* 0-1背包<br>
  * 问题描述： 有M件物品，每个物品只有一个，要么放入背包中，要么不放，所以称为0-1背包问题。M 件物品取出若干件放在空间为 N 的背包里，每种物品有且只有一个，并且有体积 w 和价值 v 两个属性。求在有限的空间内可以放入的价值最大值以及最大值由哪些物品构成。<br>
  * 解法一：dp[i][j]表示在体积为j的情况下，前i件物品的最大价值<br>
   ```python
   def bag_01(M, N, weights, values):
    # 创建一个二维数组dp，dp[i][j]表示在体积为j的情况下，前i件物品的最大value
    # 状态转移方程dp[i][j] = max(dp[i-1][j-weight[i]]+values[i], dp[i-1][j])
    # 注意第i件物品的value值和weight值都是索引-1
    dp = [[0 for _ in range(N+1)] for _ in range(M+1)]
    # 填表
    for i in range(1, M+1):
        for j in range(1, N+1):    # for j in range(weights[i-1], N+1)
            dp[i][j] = dp[i-1][j]
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]]+values[i-1])
    maxvalue = dp[M][N]

    # 回溯找到最优解由哪些元素构成:从最后一个物品开始回溯
    # 如果dp[i][j] == dp[i-1][j] 说明i物品没有放入背包
    # 如果dp[i][j] == dp[i-1][j-weights[i]] + values[i] 说明放入背包了
    
    cur_weight = N
    res = []
    for i in range(M, 0, -1):
        if dp[i][cur_weight] == dp[i-1][cur_weight-weights[i-1]] + values[i-1]: # 说明当前i物品放入背包了
            res.append(i)
            cur_weight -= weights[i-1]

    return maxvalue,res
    ```
   状态转移方程：dp[i][j] = max(dp[i-1][j],  dp[i-1][j-weight[i]] + value[i] ) 表示放与不放两种情况<br>
   填完表格后，仅能知道最大价值是多少，并不能知道是由哪些元素构成，所以通过最优解回溯，可以找到选择的物品<br>
   
  * 解法二：解法一中需要开辟一个二维数组，但是填表过程中发现第i件物品的价值至于前i-1件物品的价值有关，所以可考虑使用一位数组，只保存在当前j体积下的最大value，并不断更新。最后一个元素一定是最大值，因为它的空间j是最大的。但是这种解法会覆盖掉解的过程，无法通过回溯找到具体是由哪些背包构成最大价值。
   ```python
   def bag_01_one(M, N, weights, values):
        dp = [0 for _ in range(N+1)]
        for i in range(M):
            for j in range(N, weights[i]-1, -1):  
                dp[j] = max(dp[j], dp[j-weights[i]] + values[i])
        return dp[N]
   ```
   逆序的原因是：在计算第i件物品的时候，要用到i-1状态下的值，如果正序，用的是刚更新过的i状态下的值，逆序可以用上一状态的值  <br>
   状态转移方程：dp[j] = max(dp[j],  dp[j-weight[i]] + value[i] )(i-1状态下的，通过逆序更新来实现) <br>
   
* 完全背包  <br>
  * 问题描述：与0-1背包基本一致，但是每个物品都有若干个<br>
  * 思路：还是用dp[i][j]表示前i种物品放入到空间为j的背包中的最大价值；根据第i中物品放入的件数进行决策，对于空间j，物品i能够放入的最大件数为j/weights[i]，将其转换为0-1背包问题求解<br>
  * 解法一：
   ```python
    def complete_bag(M, N, weights, values):
         dp = [[0 for _ in range(N+1)] for _ in range(M+1)]

         for i in range(1, M+1):
             for j in range(1, N+1): # for j in range(weights[i-1], N + 1):
                 dp[i][j] = dp[i-1][j]
                 if weights[i-1] <= j:
                     for k in range(1, j // weights[i-1] + 1):  # 判断当前j可以容纳几个weights[i]，都是以i-1为基础的情况下
                         dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weights[i-1]] + values[i-1]*k)
         return dp[M][N]
    ```
    状态转移公式为：dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weights[i]] + k* values[i])  k取值范围为[0, j/weights[i]]
  * 优化一：<br>
 对于第i件物品，考虑放还是不放：<br>
  不放： dp[i][j] = dp[i-1][j] <br>
  放: dp[i][j]中至少会出现一件物品i，认为之前已经最大限度地放置了物品i，如果能够放进去，就放最后一件，则此时dp[i][j] = dp[i][j-weights[i]] + values[i]，注意此处与0-1背包的区别
  ```python
  def complete_bag1(M, N, weights, values):
    dp = [[0 for _ in range(N+1)] for _ in range(M+1)]
    for i in range(1, M+1):
        for j in range(1, N+1):
            dp[i][j] = dp[i-1][j]
            if weights[i-1] <= j:
                    dp[i][j] = max(dp[i][j], dp[i][j-weights[i-1]] + values[i-1])
    return dp[M][N]

  ```
  * 优化二：<br>
 使用一维数组进行存储，状态转移公式为：dp[j] = max(dp[j], dp[j-weights[i]] + values[i])与0-1背包的优化公式一样，但其实是不同的，不同点在于：<br>
 0-1背包中：计算第i个物品的时候，倒序求解dp[j]，因为要使用i-1状态下的值<br>
 完全背包中：不需要倒序求解，因为每个物品可以反复加入，那么在计算第i个物品的时候，就用当前更新过的值即可
 ```python
 def complete_bag(M, N, weights, values):
    dp = [0 for _ in range(N+1)]
    for i in range(1, M+1):
        for j in range(weights[i-1], N+1): 
             dp[j] = max (dp[j], dp[j-weights[i-1]] + values[i-1])
    return dp[N]
 ``` 
* 二维费用的背包<br>
  * 问题描述：二维费用的意思是在将物品放入背包的时候，必须付出两种费用（比如体积和重量），即需要考虑的代价是二维的<br>
  * 实例：小偷深夜潜入一家珠宝店，店里有5类宝物，重量分别为W{1,3,2,4,5}，各类宝物的体积为C{2,1,3,1,2}，对应的价值为V{200,100,300,150,350 }。小偷随身只携带了一个容量为5，承重为4的背包，问小偷应如何选择才能使偷得宝物的价值最大？<br>
  * 思路：由于费用增加一维度，所以可开辟一个三维数组，dp[i][j][k]存储第i件物品，在费用1为j和费用2为k的情况下的最大价值
   ```python
   def bag_twovectors(M, N1, N2, weights, cost, values):
       dp = [[[0 for _ in range(N2+1)] for _ in range(N1+1)] for _ in range(M+1)]
       for i in range(1, M+1):
           for j in range(1, N1+1):
               for k in range(1, N2+1):
                   dp[i][j][k] = dp[i-1][j][k]
                   if weights[i-1] <= j and cost[i-1] <= k:
                       dp[i][j][k] = max(dp[i][j][k],  dp[i-1][j-weights[i-1]][k-cost[i-1]] + values[i-1])
       return dp[M][N1][N2]
   ```
   状态转移方程为： dp[i][j][k] = max(dp[i-1][j][k],  dp[i-1][j- weights[i]][k- c[i]] + values[i]).
  * 优化：参考之前的二维空间优化为一维，这里可以将三维空间优化为二维空间dp[j][k]
   ```python
   def bag_twovectors_new(M, N1, N2, weights, cost, values):
     dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]
     for i in range(1, M+1):
         for j in range(N1,  weights[i-1] -1, -1):
             for k in range(N2,cost[i-1]-1, -1):
                   dp[j][k] = max(dp[j][k], dp[j-weights[i-1]][k-cost[i-1]] + values[i-1])

    return dp[N1][N2]
   ```
  状态转移方程为： dp[j][k] = max (dp[j][k], dp[j-weights[i]][k-c[i]] + values[i])
  
  ### 背包问题总结：对于想简化空间的情况，如果是0-1背包，要倒序；如果是完全背包，要正序
  
  
* 背包问题Leetcode习题：
  * [139. Word Break](https://leetcode.com/problems/word-break/description/)
  ```python
  class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        size = len(s)
        # dp[i]表示第i个字符是否被分割
        dp = [0 for i in range(size + 1)]
        dp[0] = 1 # 第0个字符肯定可以被分割
        
        for i in range(1, size+1):
            for word in wordDict:
                if dp[i-len(word)] and s[i-len(word):i] == word: # 注意下标第i个字符，在s中索引是i-1
                    dp[i] = 1
    
        return dp[size]
  ```
  思路：dp[i]记录原来s中的第i个字符是否可以被分割。举个例子：s = applepenapple, 单词表为['apple', 'pen']， 当需要判断第5个字符‘e’的时候，对于单词表中的apple，就用e的位置下标减去apple的长度，得到原始s中apple的一个分词，只有当分词前一个字符也是可以被分割的且分词得到的单词与当前判断的单词表中的单词相等时，dp[i]才为1.例子中dp=[0,0,0,0,0,1,0,0,1,0,0,0,0,1]
  
  * [322. Coin Change](https://leetcode.com/problems/coin-change/submissions/)
  换硬币：完全背包的变形
  解法一：
  ```python
  class Solution(object):
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        # 完全背包问题，dp[i][j] 表示第i个硬币做成价值为j的最小个数
        size = len(coins)
        maxnum = float('inf')
        dp = [ [0] + [maxnum for _ in range(amount)] for _ in range(size+1)]

        for i in range(1, size+1):
            for j in range(1, amount+1):
                dp[i][j] = dp[i-1][j]
                if j >= coins[i-1]:
                    dp[i][j] = min(dp[i][j], dp[i][j-coins[i-1]] + 1)
        
        if dp[size][amount] == maxnum:
            return -1
        return dp[size][amount]
  ```
  
  解法二：
  ```python
  class Solution(object):
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        # 优化空间
        size = len(coins)
        maxnum = float('inf')
        dp = [0] + [maxnum for _ in range(amount)]
        
        for i in range(1, size+1):
            for j in range(coins[i-1], amount+1):
                dp[j] = min(dp[j], dp[j-coins[i-1]] + 1)
        
        if dp[amount] == maxnum:
            return -1
        return dp[amount]
  ```
  
  * [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/description/)
  ```python
  class Solution(object):
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # dp[i]表示当target为i时，解法的个数
        dp = [1] + [0] * target # dp[0]= 1是因为当num等于i时，需要用到dp[0]，此时应该增加一种解法
        
        for i in range(1, target+1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i-num]
        return dp[target]
  ```
  状态转移方程：dp[i] = sum(dp[i-num]) 其中i>=num
  
  ```python
  # 超时的递归方法，便于理解
  class Solution(object):
    def helper(self, nums, cur_target):
        if cur_target == 0:
            return 1
        res = 0
        for num in nums:
            if cur_target >= num:
                res += self.helper(nums, cur_target - num)         
        return res
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.helper(nums, target)
  ```
  超时的原因在于有大量的重复计算，比如:假设求dp[3]的时候计算了dp[2]，等到求dp[4]的时候，如果再次用到dp[2]， 需要再次计算，因此改进方法是利用一个数组存储已经计算过了的值，借鉴dp方法
  ```python
  class Solution(object):
    def helper(self, nums, cur_target):
        if self.dp[cur_target] != -1:
            return self.dp[cur_target]
        
        res = 0
        for num in nums:
            if cur_target >= num:
                res += self.helper(nums, cur_target - num)
        
        self.dp[cur_target] = res
        return res
    
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # 改进的递归方法
        self.dp = [1] + [-1] * target
        return self.helper(nums, target)
  ```
  思考？？这种方法只能判断有几种组成方法，如果要找到具体每种方法是如何构成的，该怎么做？？  [39. Combination Sum]系列待补充
  
  * [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/)
  ```python
  class Solution(object):    
    def bag_01(self, nums, target):
        size = len(nums)
        dp = [0 for _ in range(target+1)]
        for i in range(1, size+1):
            for j in range(target, 0, -1):
                if j - nums[i-1] >= 0 and dp[j-nums[i-1]] + nums[i-1] > dp[j]:
                    dp[j] = dp[j-nums[i-1]] + nums[i-1]
                if dp[j] == target:
                    return True
        return False
    
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        total = sum(nums)
        
        if total % 2:
            return False
        target = total // 2
        # 0-1背包问题，这个背包容量为target，且必须被填满  
        return self.bag_01(nums, target)
        
  ```
  
  * [474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/)
  ```python
  class Solution(object):
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        # 二维费用的背包问题
        zeros = []
        ones = []
        for s in strs:
            zeros.append(s.count('0'))  # m
            ones.append(s.count('1'))   # n
         
        size = len(strs)
        
        dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
        
        for i in range(1, size+1):
            for j in range(n, ones[i-1]-1, -1):
                for k in range(m, zeros[i-1]-1, -1):
                    dp[j][k] = max(dp[j][k], dp[j-ones[i-1]][k-zeros[i-1]] + 1)
                        
        return dp[n][m]
  ```
  本题可以看成是二维背包费用的问题：0和1的个数是背包的两个参数（容量和体积），每个str中拥有的0和1的个数看做是对应物品的重量和体积，每个物品的价值都是1，求可以放入背包的物品的最大价值。与前面不同的是，此处的变量会有0的存在，导致二层和三层循环的终止应该是到0； 代码中简化了这里的写法，建议：背包问题，如果用降维空间的写法时，遍历的终止条件按照当前写法，不要写到0然后再在后面判断j和k是否大于对应的物品的重量和体积。
  
  * [494. Target Sum](https://leetcode.com/problems/target-sum/description/)
  ```python
  class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S: int
        :rtype: int
        """
        # 转化为0-1背包问题,寻找和为(S+sum(nums))//2 的组成个数
        # 状态转移方程：dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]
        
        summ = sum(nums)
        if summ < S or (S + summ) % 2:
            return 0
        
        target = (S + summ) // 2
        dp = [1] + [0] * target
        size = len(nums)
        for i in range(1, size+1):
            for j in range(target, nums[i-1]-1, -1):
                dp[j] += dp[j-nums[i-1]]
                
        return dp[target] 
  ```
  思路： 设nums中符号为+的数字，组成的集合为P; 符号为-的数字，组成的集合为N，则： 
  > sum(P) - sum(N) = S 且sum(P) + sum(N) = sum(nums);
  所以：sum(P)=(S + sum(nums) )/2
  
  因此该问题可以看成一个 0-1背包问题，从给定的 nums[] 中选出一个子集，如果其和等于 (S+ sum(nums)) // 2, 则这个子集符合题意，找到有多少个这样的子集即得到所有的方法。<br>
  用 dp[i][j] 表示前 i 个数的和为 j 的方法总数。第 i 个数可以选择放入背包或者不放入，则状态转移公式为:<br>
  dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]<br>
  简化后是：dp[j] = dp[j] + dp[i-nums[i]]
  
## 分割整数
* [91. Decode Ways](https://leetcode.com/problems/decode-ways/description/)

* [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/description/)

## 数组区间
* 
* 

   
   
