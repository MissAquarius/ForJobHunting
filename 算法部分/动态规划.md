# 动态规划
把原问题分解为相对简单的子问题的方式，求解复杂问题。常用于求最优子结构性质的问题以及有重叠子问题。

## 基本思想
求解原问题，需要解不同的部分（子问题），再合并子问题的解得出原问题的解。通常子问题非常相似，所以dp方法识图解决子问题一次，从而减少计算量。
一旦一个子问题已经算出，则将其存储，等下次需要同一个子问题求解时，直接查表。

## 问题特征
* 最优子结构：问题的最优解包含子问题的最优解
* 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。

## 分治法与动态规划算法不同
* 相同点：二者都是讲原问题分解成若干个规模比较小的子问题求解，然后将子问题的解合并，形成原问题的解
* 不同点：分治法分解的子问题是相互独立的,常用递归解决；而动态规划分解后的子问题之间互相有联系，有重叠部分，需要存储每个子问题的解，常用迭代解决

## LeetCode例题
* 斐波那契数列(可以不用数组保存值，为了节省空间，可用常量保存需要的两个值即可)
  * [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/):
  ```python
  class Solution(object):        
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:  # 第一个台阶，有一种上法
            return 1
        if n == 2:  # 第二个台阶，有两种上法
            return 2
        
        # 从第三个台阶开始，每个台阶的可以从其倒数第一个台阶（上一步）和倒数第二个台阶（上两步）解法加和。用a和b分别表示这两种情况，并不断更新a和b值
        a = 1
        b = 2
        for i in range(n-2):
            res = a + b
            a = b
            b = res
        return res
  ```
  状态转移方程：dp[i] = dp[i-1] + dp[i-2]
  
  * [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)
  ```python
  class Solution(object):
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        # 到达第i层的cost是不需要加上cost[i]的
        dp = [0, 0]  # 存储到达每一层的cost，初始时，到达第0层需要0，到达第1层需要0
        
        # 从第2层开始计算，直到顶部，即：第len(cost)层
        for i in range(2, len(cost)+1):
            dp.append(min(cost[i-1]+ dp[i-1], cost[i-2]+ dp[i-2]))
            
        return dp[-1]
  ```
  状态转移方程：dp[i] = max(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    
  * [198. House Robber](https://leetcode.com/problems/house-robber/description/)
  ```python
  class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        # dp存储到第i户的最大抢劫数目：该值等于max（第i-1户，第i-2户+当前户），初始是存储第0户和第1户
        dp  = [0, nums[0]]
        for i in range(2, size+1):
            dp.append(max(dp[i-1], dp[i-2]+nums[i-1]))
        
        return max(dp[size], dp[size-1])
  ```
  状态转移方程：dp[i] = max(dp[i-1] , dp[i-2] + value[i])
  
  * [213. House Robber II](https://leetcode.com/problems/house-robber-ii/description/)
  ```python
  class Solution(object): 
    def rob_house(self, nums):
        size = len(nums)
        
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        pre_2, pre_1 = 0, nums[0]
        
        for i in range(2, size+1):
            cur = max(pre_1, pre_2+nums[i-1])
            pre_2 = pre_1
            pre_1 = cur
        
        return max(cur, pre_1)
        
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 与上一题类似，只不过这里变成环形，可以求去掉第一个元素和去掉最后一个元素，然后二者取最大值
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        # nums长度大于2时，开始掐头去尾的比较
        return max(self.rob_house(nums[:-1]), self.rob_house(nums[1:]))
        
  ```
  
* 背包问题
 * 0-1背包<br>
   问题描述： 有M件物品，每个物品只有一个，要么放入背包中，要么不放，所以称为0-1背包问题。M 件物品取出若干件放在空间为 N 的背包里，每种物品有且只有一个，并且有体积 w 和价值 v 两个属性。求在有限的空间内可以放入的价值最大值以及最大值由哪些物品构成。<br>
   思路：<br>
   解法一：dp[i][j]表示在体积为j的情况下，前i件物品的最大价值<br>
   ```python
   def bag_01(M, N, weights, values):
    # 创建一个二维数组dp，dp[i][j]表示在体积为j的情况下，前i件物品的最大value
    # 状态转移方程dp[i][j] = max(dp[i-1][j-weight[i]]+values[i], dp[i-1][j])
    # 注意第i件物品的value值和weight值都是索引-1
    dp = [[0 for _ in range(N+1)] for _ in range(M+1)]
    # 填表
    for i in range(1, M+1):
        for j in range(1, N+1):    # for j in range(weights[i-1], N+1)
            dp[i][j] = dp[i-1][j]
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]]+values[i-1])
    maxvalue = dp[M][N]

    # 回溯找到最优解由哪些元素构成:从最后一个物品开始回溯
    # 如果dp[i][j] == dp[i-1][j] 说明i物品没有放入背包
    # 如果dp[i][j] == dp[i-1][j-weights[i]] + values[i] 说明放入背包了
    
    cur_weight = N
    res = []
    for i in range(M, 0, -1):
        if dp[i][cur_weight] == dp[i-1][cur_weight-weights[i-1]] + values[i-1]: # 说明当前i物品放入背包了
            res.append(i)
            cur_weight -= weights[i-1]

    return maxvalue,res
    ```
   状态转移方程：dp[i][j] = max(dp[i-1][j],  dp[i-1][j-weight[i]] + value[i] ) 表示放与不放两种情况<br>
   填完表格后，仅能知道最大价值是多少，并不能知道是由哪些元素构成，所以通过最优解回溯，可以找到选择的物品<br>
   
   解法二：解法一中需要开辟一个二维数组，但是填表过程中发现第i件物品的价值至于前i-1件物品的价值有关，所以可考虑使用一位数组，只保存在当前j体积下的最大value，并不断更新。最后一个元素一定是最大值，因为它的空间j是最大的。但是这种解法会覆盖掉解的过程，无法通过回溯找到具体是由哪些背包构成最大价值。
   ```python
   def bag_01_one(M, N, weights, values):
        dp = [0 for _ in range(N+1)]
        for i in range(M):
            for j in range(N, 0, -1):  
            # for j in range(N, weights[i]-1, -1): 可以减少计算量
            # 逆序的原因是：在计算第i件物品的时候，要用到i-1状态下的值，如果正序，用的是刚更新过的i状态下的值，逆序可以用上一状态的值
                if j - weights[i] >= 0 and dp[j-weights[i]]+ values[i] > dp[j]: 
                    dp[j] = dp[j-weights[i]] + values[i]
            print(dp)
        return dp[N]
   ```
   状态转移方程：dp[j] = max(dp[j],  dp[j-weight[i]] + value[i] )(i-1状态下的，通过逆序更新来实现) <br>
   
   
 * 完全背包  <br>
 问题描述：与0-1背包基本一致，但是每个物品都有若干个<br>
 思路：还是用dp[i][j]表示前i种物品放入到空间为j的背包中的最大价值；根据第i中物品放入的件数进行决策，对于空间j，物品i能够放入的最大件数为j/weights[i]，将其转换为0-1背包问题求解<br>
 状态转移公式为：dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weights[i]] + k* values[i])  k取值范围为[0, j/weights[i]] <br>
 ```python
    def complete_bag(M, N, weights, values):
         dp = [[0 for _ in range(N+1)] for _ in range(M+1)]
       # print(len(dp[0]))
         for i in range(1, M+1):
             for j in range(1, N+1): # for j in range(weights[i-1], N + 1):
                 dp[i][j] = dp[i-1][j]
                 if weights[i-1] <= j:
                     for k in range(1, j // weights[i-1] + 1):  # 判断当前j可以容纳几个weights[i]，都是以i-1为基础的情况下
                         dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weights[i-1]] + values[i-1]*k)
         return dp[M][N]
 ```
 优化一：<br>
 对于第i件物品，考虑放还是不放：<br>
  不放： dp[i][j] = dp[i-1][j] <br>
  放,dp[i][j]中至少会出现一件物品i，认为之前已经最大限度地放置了物品i，如果能够放进去，就放最后一件，则此时dp[i][j] = dp[i][j-weights[i]] + values[i]，注意此处与0-1背包的区别
  ```python
  def complete_bag1(M, N, weights, values):
    dp = [[0 for _ in range(N+1)] for _ in range(M+1)]
    for i in range(1, M+1):
        for j in range(1, N+1):
            dp[i][j] = dp[i-1][j]
            if weights[i-1] <= j:
                    dp[i][j] = max(dp[i][j], dp[i][j-weights[i-1]] + values[i-1])
    return dp[M][N]

  ```
 优化二：<br>
 使用一维数组进行存储，状态转移公式为：dp[j] = max(dp[j], dp[j-weights[i]] + values[i])与0-1背包的优化公式一样，但其实是不同的，不同点在于：<br>
 0-1背包中：计算第i个物品的时候，倒序求解dp[j]，因为要使用i-1状态下的值<br>
 完全背包中：不需要倒序求解，因为每个物品可以反复加入，那么在计算第i个物品的时候，就用当前更新过的值即可
 ```python
 def complete_bag(M, N, weights, values):
    dp = [0 for _ in range(N+1)]
    for i in range(1, M+1):
        # for j in range(weights[i-1], N+1):
        for j in range(1, N+1):
            if j >= weights[i-1] and dp[j] < dp[j-weights[i-1]] + values[i-1]:
                dp[j] = dp[j-weights[i-1]] + values[i-1]
    return dp[N]
 ```
 
 
 * 二维费用的背包<br>
   问题描述：二维费用的意思是在将物品放入背包的时候，必须付出两种费用（比如体积和重量），即需要考虑的代价是二维的<br>
   实例：小偷深夜潜入一家珠宝店，店里有5类宝物，重量分别为W{1,3,2,4,5}，各类宝物的体积为C{2,1,3,1,2}，对应的价值为V{200,100,300,150,350 }。小偷随身只携带了一个容量为5，承重为4的背包，问小偷应如何选择才能使偷得宝物的价值最大？<br>
   
   
   
