# 动态规划
把原问题分解为相对简单的子问题的方式，求解复杂问题。常用于求最优子结构性质的问题以及有重叠子问题。

## 基本思想
求解原问题，需要解不同的部分（子问题），再合并子问题的解得出原问题的解。通常子问题非常相似，所以dp方法识图解决子问题一次，从而减少计算量。
一旦一个子问题已经算出，则将其存储，等下次需要同一个子问题求解时，直接查表。

## 问题特征
* 最优子结构：问题的最优解包含子问题的最优解
* 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。

## 分治法与动态规划算法不同
* 相同点：二者都是讲原问题分解成若干个规模比较小的子问题求解，然后将子问题的解合并，形成原问题的解
* 不同点：分治法分解的子问题是相互独立的,常用递归解决；而动态规划分解后的子问题之间互相有联系，有重叠部分，需要存储每个子问题的解，常用迭代解决

## LeetCode例题
* 斐波那契数列(可以不用数组保存值，为了节省空间，可用常量保存需要的两个值即可)
  * [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/):
  ```python
  class Solution(object):        
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:  # 第一个台阶，有一种上法
            return 1
        if n == 2:  # 第二个台阶，有两种上法
            return 2
        
        # 从第三个台阶开始，每个台阶的可以从其倒数第一个台阶（上一步）和倒数第二个台阶（上两步）解法加和。用a和b分别表示这两种情况，并不断更新a和b值
        a = 1
        b = 2
        for i in range(n-2):
            res = a + b
            a = b
            b = res
        return res
  ```
  状态转移方程：dp[i] = dp[i-1] + dp[i-2]
  
  * [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)
  ```python
  class Solution(object):
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        # 到达第i层的cost是不需要加上cost[i]的
        dp = [0, 0]  # 存储到达每一层的cost，初始时，到达第0层需要0，到达第1层需要0
        
        # 从第2层开始计算，直到顶部，即：第len(cost)层
        for i in range(2, len(cost)+1):
            dp.append(min(cost[i-1]+ dp[i-1], cost[i-2]+ dp[i-2]))
            
        return dp[-1]
  ```
  状态转移方程：dp[i] = max(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    
  * [198. House Robber](https://leetcode.com/problems/house-robber/description/)
  ```python
  class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        # dp存储到第i户的最大抢劫数目：该值等于max（第i-1户，第i-2户+当前户），初始是存储第0户和第1户
        dp  = [0, nums[0]]
        for i in range(2, size+1):
            dp.append(max(dp[i-1], dp[i-2]+nums[i-1]))
        
        return max(dp[size], dp[size-1])
  ```
  状态转移方程：dp[i] = max(dp[i-1] , dp[i-2] + value[i])
  
  * [213. House Robber II](https://leetcode.com/problems/house-robber-ii/description/)
  ```python
  class Solution(object): 
    def rob_house(self, nums):
        size = len(nums)
        
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        pre_2, pre_1 = 0, nums[0]
        
        for i in range(2, size+1):
            cur = max(pre_1, pre_2+nums[i-1])
            pre_2 = pre_1
            pre_1 = cur
        
        return max(cur, pre_1)
        
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 与上一题类似，只不过这里变成环形，可以求去掉第一个元素和去掉最后一个元素，然后二者取最大值
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        # nums长度大于2时，开始掐头去尾的比较
        return max(self.rob_house(nums[:-1]), self.rob_house(nums[1:]))
        
  ```
  
* 背包问题
 * [0-1背包]<br>
   问题描述： M 件物品取出若干件放在空间为 N 的背包里，每种物品有且只有一个，并且有体积 w 和价值 v 两个属性。求在有限的空间内可以放入的价值最大值。<br>
   思路：<br>
   解法：dp[i][j]表示在体积为j的情况下，前i件物品的最大价值<br>
   ```python
   def bag_01(M, N, weights, values):
   
   ```
   状态转移方程：dp[i][j] = max(dp[i-1][j],  dp[i-1][j-weight[j]] + value[i] ) 表示放与不放两种情况

