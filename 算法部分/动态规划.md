# 动态规划
把原问题分解为相对简单的子问题的方式，求解复杂问题。常用于求最优子结构性质的问题以及有重叠子问题。

## 基本思想
求解原问题，需要解不同的部分（子问题），再合并子问题的解得出原问题的解。通常子问题非常相似，所以dp方法识图解决子问题一次，从而减少计算量。
一旦一个子问题已经算出，则将其存储，等下次需要同一个子问题求解时，直接查表。

## 问题特征
* 最优子结构：问题的最优解包含子问题的最优解
* 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。

## 分治法与动态规划算法不同
* 相同点：二者都是讲原问题分解成若干个规模比较小的子问题求解，然后将子问题的解合并，形成原问题的解
* 不同点：分治法分解的子问题是相互独立的,常用递归解决；而动态规划分解后的子问题之间互相有联系，有重叠部分，需要存储每个子问题的解，常用迭代解决

## 斐波那契数列(可以不用数组保存值，为了节省空间，可用常量保存需要的两个值即可)
* [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/):
  ```python
  class Solution(object):        
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:  # 第一个台阶，有一种上法
            return 1
        if n == 2:  # 第二个台阶，有两种上法
            return 2
        
        # 从第三个台阶开始，每个台阶的可以从其倒数第一个台阶（上一步）和倒数第二个台阶（上两步）解法加和。用a和b分别表示这两种情况，并不断更新a和b值
        a = 1
        b = 2
        for i in range(n-2):
            res = a + b
            a = b
            b = res
        return res
  ```
  状态转移方程：dp[i] = dp[i-1] + dp[i-2]
  
* [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)
  ```python
  class Solution(object):
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        # 到达第i层的cost是不需要加上cost[i]的
        dp = [0, 0]  # 存储到达每一层的cost，初始时，到达第0层需要0，到达第1层需要0
        
        # 从第2层开始计算，直到顶部，即：第len(cost)层
        for i in range(2, len(cost)+1):
            dp.append(min(cost[i-1]+ dp[i-1], cost[i-2]+ dp[i-2]))
            
        return dp[-1]
  ```
  状态转移方程：dp[i] = max(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    
* [198. House Robber](https://leetcode.com/problems/house-robber/description/)
  ```python
  class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        # dp存储到第i户的最大抢劫数目：该值等于max（第i-1户，第i-2户+当前户），初始是存储第0户和第1户
        dp  = [0, nums[0]]
        for i in range(2, size+1):
            dp.append(max(dp[i-1], dp[i-2]+nums[i-1]))
        
        return max(dp[size], dp[size-1])
  ```
  状态转移方程：dp[i] = max(dp[i-1] , dp[i-2] + value[i])
  
* [213. House Robber II](https://leetcode.com/problems/house-robber-ii/description/)
  ```python
  class Solution(object): 
    def rob_house(self, nums):
        size = len(nums)
        
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        pre_2, pre_1 = 0, nums[0]
        
        for i in range(2, size+1):
            cur = max(pre_1, pre_2+nums[i-1])
            pre_2 = pre_1
            pre_1 = cur
        
        return max(cur, pre_1)
        
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 与上一题类似，只不过这里变成环形，可以求去掉第一个元素和去掉最后一个元素，然后二者取最大值
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]
        # nums长度大于2时，开始掐头去尾的比较
        return max(self.rob_house(nums[:-1]), self.rob_house(nums[1:]))
        
  ```
  
## 背包问题：0-1背包、完全背包、二维费用背包
* 0-1背包<br>
  * 问题描述： 有M件物品，每个物品只有一个，要么放入背包中，要么不放，所以称为0-1背包问题。M 件物品取出若干件放在空间为 N 的背包里，每种物品有且只有一个，并且有体积 w 和价值 v 两个属性。求在有限的空间内可以放入的价值最大值以及最大值由哪些物品构成。<br>
  * 解法一：dp[i][j]表示在体积为j的情况下，前i件物品的最大价值<br>
   ```python
   def bag_01(M, N, weights, values):
    # 创建一个二维数组dp，dp[i][j]表示在体积为j的情况下，前i件物品的最大value
    # 状态转移方程dp[i][j] = max(dp[i-1][j-weight[i]]+values[i], dp[i-1][j])
    # 注意第i件物品的value值和weight值都是索引-1
    dp = [[0 for _ in range(N+1)] for _ in range(M+1)]
    # 填表
    for i in range(1, M+1):
        for j in range(1, N+1):    # for j in range(weights[i-1], N+1)
            dp[i][j] = dp[i-1][j]
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]]+values[i-1])
    maxvalue = dp[M][N]

    # 回溯找到最优解由哪些元素构成:从最后一个物品开始回溯
    # 如果dp[i][j] == dp[i-1][j] 说明i物品没有放入背包
    # 如果dp[i][j] == dp[i-1][j-weights[i]] + values[i] 说明放入背包了
    
    cur_weight = N
    res = []
    for i in range(M, 0, -1):
        if dp[i][cur_weight] == dp[i-1][cur_weight-weights[i-1]] + values[i-1]: # 说明当前i物品放入背包了
            res.append(i)
            cur_weight -= weights[i-1]

    return maxvalue,res
    ```
   状态转移方程：dp[i][j] = max(dp[i-1][j],  dp[i-1][j-weight[i]] + value[i] ) 表示放与不放两种情况<br>
   填完表格后，仅能知道最大价值是多少，并不能知道是由哪些元素构成，所以通过最优解回溯，可以找到选择的物品<br>
   
  * 解法二：解法一中需要开辟一个二维数组，但是填表过程中发现第i件物品的价值至于前i-1件物品的价值有关，所以可考虑使用一位数组，只保存在当前j体积下的最大value，并不断更新。最后一个元素一定是最大值，因为它的空间j是最大的。但是这种解法会覆盖掉解的过程，无法通过回溯找到具体是由哪些背包构成最大价值。
   ```python
   def bag_01_one(M, N, weights, values):
        dp = [0 for _ in range(N+1)]
        for i in range(M):
            for j in range(N, weights[i]-1, -1):  
                dp[j] = max(dp[j], dp[j-weights[i]] + values[i])
        return dp[N]
   ```
   逆序的原因是：在计算第i件物品的时候，要用到i-1状态下的值，如果正序，用的是刚更新过的i状态下的值，逆序可以用上一状态的值  <br>
   状态转移方程：dp[j] = max(dp[j],  dp[j-weight[i]] + value[i] )(i-1状态下的，通过逆序更新来实现) <br>
   
* 完全背包  <br>
  * 问题描述：与0-1背包基本一致，但是每个物品都有若干个<br>
  * 思路：还是用dp[i][j]表示前i种物品放入到空间为j的背包中的最大价值；根据第i中物品放入的件数进行决策，对于空间j，物品i能够放入的最大件数为j/weights[i]，将其转换为0-1背包问题求解<br>
  * 解法一：
   ```python
    def complete_bag(M, N, weights, values):
         dp = [[0 for _ in range(N+1)] for _ in range(M+1)]

         for i in range(1, M+1):
             for j in range(1, N+1): # for j in range(weights[i-1], N + 1):
                 dp[i][j] = dp[i-1][j]
                 if weights[i-1] <= j:
                     for k in range(1, j // weights[i-1] + 1):  # 判断当前j可以容纳几个weights[i]，都是以i-1为基础的情况下
                         dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weights[i-1]] + values[i-1]*k)
         return dp[M][N]
    ```
    状态转移公式为：dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weights[i]] + k* values[i])  k取值范围为[0, j/weights[i]]
  * 优化一：<br>
 对于第i件物品，考虑放还是不放：<br>
  不放： dp[i][j] = dp[i-1][j] <br>
  放: dp[i][j]中至少会出现一件物品i，认为之前已经最大限度地放置了物品i，如果能够放进去，就放最后一件，则此时dp[i][j] = dp[i][j-weights[i]] + values[i]，注意此处与0-1背包的区别
  ```python
  def complete_bag1(M, N, weights, values):
    dp = [[0 for _ in range(N+1)] for _ in range(M+1)]
    for i in range(1, M+1):
        for j in range(1, N+1):
            dp[i][j] = dp[i-1][j]
            if weights[i-1] <= j:
                    dp[i][j] = max(dp[i][j], dp[i][j-weights[i-1]] + values[i-1])
    return dp[M][N]

  ```
  * 优化二：<br>
 使用一维数组进行存储，状态转移公式为：dp[j] = max(dp[j], dp[j-weights[i]] + values[i])与0-1背包的优化公式一样，但其实是不同的，不同点在于：<br>
 0-1背包中：计算第i个物品的时候，倒序求解dp[j]，因为要使用i-1状态下的值<br>
 完全背包中：不需要倒序求解，因为每个物品可以反复加入，那么在计算第i个物品的时候，就用当前更新过的值即可
 ```python
 def complete_bag(M, N, weights, values):
    dp = [0 for _ in range(N+1)]
    for i in range(1, M+1):
        for j in range(weights[i-1], N+1): 
             dp[j] = max (dp[j], dp[j-weights[i-1]] + values[i-1])
    return dp[N]
 ``` 
* 二维费用的背包<br>
  * 问题描述：二维费用的意思是在将物品放入背包的时候，必须付出两种费用（比如体积和重量），即需要考虑的代价是二维的<br>
  * 实例：小偷深夜潜入一家珠宝店，店里有5类宝物，重量分别为W{1,3,2,4,5}，各类宝物的体积为C{2,1,3,1,2}，对应的价值为V{200,100,300,150,350 }。小偷随身只携带了一个容量为5，承重为4的背包，问小偷应如何选择才能使偷得宝物的价值最大？<br>
  * 思路：由于费用增加一维度，所以可开辟一个三维数组，dp[i][j][k]存储第i件物品，在费用1为j和费用2为k的情况下的最大价值
   ```python
   def bag_twovectors(M, N1, N2, weights, cost, values):
       dp = [[[0 for _ in range(N2+1)] for _ in range(N1+1)] for _ in range(M+1)]
       for i in range(1, M+1):
           for j in range(1, N1+1):
               for k in range(1, N2+1):
                   dp[i][j][k] = dp[i-1][j][k]
                   if weights[i-1] <= j and cost[i-1] <= k:
                       dp[i][j][k] = max(dp[i][j][k],  dp[i-1][j-weights[i-1]][k-cost[i-1]] + values[i-1])
       return dp[M][N1][N2]
   ```
   状态转移方程为： dp[i][j][k] = max(dp[i-1][j][k],  dp[i-1][j- weights[i]][k- c[i]] + values[i]).
  * 优化：参考之前的二维空间优化为一维，这里可以将三维空间优化为二维空间dp[j][k]
   ```python
   def bag_twovectors_new(M, N1, N2, weights, cost, values):
     dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]
     for i in range(1, M+1):
         for j in range(N1,  weights[i-1] -1, -1):
             for k in range(N2,cost[i-1]-1, -1):
                   dp[j][k] = max(dp[j][k], dp[j-weights[i-1]][k-cost[i-1]] + values[i-1])

    return dp[N1][N2]
   ```
  状态转移方程为： dp[j][k] = max (dp[j][k], dp[j-weights[i]][k-c[i]] + values[i])
  
  ### 背包问题总结：对于想简化空间的情况，如果是0-1背包，要倒序；如果是完全背包，要正序
  
  
* 背包问题Leetcode习题：
  * [139. Word Break](https://leetcode.com/problems/word-break/description/)
  ```python
  class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        size = len(s)
        # dp[i]表示第i个字符是否被分割
        dp = [0 for i in range(size + 1)]
        dp[0] = 1 # 第0个字符肯定可以被分割
        
        for i in range(1, size+1):
            for word in wordDict:
                if dp[i-len(word)] and s[i-len(word):i] == word: # 注意下标第i个字符，在s中索引是i-1
                    dp[i] = 1
    
        return dp[size]
  ```
  思路：dp[i]记录原来s中的第i个字符是否可以被分割。举个例子：s = applepenapple, 单词表为['apple', 'pen']， 当需要判断第5个字符‘e’的时候，对于单词表中的apple，就用e的位置下标减去apple的长度，得到原始s中apple的一个分词，只有当分词前一个字符也是可以被分割的且分词得到的单词与当前判断的单词表中的单词相等时，dp[i]才为1.例子中dp=[0,0,0,0,0,1,0,0,1,0,0,0,0,1]
  
  * [322. Coin Change](https://leetcode.com/problems/coin-change/submissions/)
  换硬币：完全背包的变形
  解法一：
  ```python
  class Solution(object):
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        # 完全背包问题，dp[i][j] 表示第i个硬币做成价值为j的最小个数
        size = len(coins)
        maxnum = float('inf')
        dp = [ [0] + [maxnum for _ in range(amount)] for _ in range(size+1)]

        for i in range(1, size+1):
            for j in range(1, amount+1):
                dp[i][j] = dp[i-1][j]
                if j >= coins[i-1]:
                    dp[i][j] = min(dp[i][j], dp[i][j-coins[i-1]] + 1)
        
        if dp[size][amount] == maxnum:
            return -1
        return dp[size][amount]
  ```
  
  解法二：
  ```python
  class Solution(object):
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        # 优化空间
        size = len(coins)
        maxnum = float('inf')
        dp = [0] + [maxnum for _ in range(amount)]
        
        for i in range(1, size+1):
            for j in range(coins[i-1], amount+1):
                dp[j] = min(dp[j], dp[j-coins[i-1]] + 1)
        
        if dp[amount] == maxnum:
            return -1
        return dp[amount]
  ```
  
  * [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/description/)
  ```python
  class Solution(object):
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # dp[i]表示当target为i时，解法的个数
        dp = [1] + [0] * target # dp[0]= 1是因为当num等于i时，需要用到dp[0]，此时应该增加一种解法
        
        for i in range(1, target+1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i-num]
        return dp[target]
  ```
  状态转移方程：dp[i] = sum(dp[i-num]) 其中i>=num
  
  ```python
  # 超时的递归方法，便于理解
  class Solution(object):
    def helper(self, nums, cur_target):
        if cur_target == 0:
            return 1
        res = 0
        for num in nums:
            if cur_target >= num:
                res += self.helper(nums, cur_target - num)         
        return res
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.helper(nums, target)
  ```
  超时的原因在于有大量的重复计算，比如:假设求dp[3]的时候计算了dp[2]，等到求dp[4]的时候，如果再次用到dp[2]， 需要再次计算，因此改进方法是利用一个数组存储已经计算过了的值，借鉴dp方法
  ```python
  class Solution(object):
    def helper(self, nums, cur_target):
        if self.dp[cur_target] != -1:
            return self.dp[cur_target]
        
        res = 0
        for num in nums:
            if cur_target >= num:
                res += self.helper(nums, cur_target - num)
        
        self.dp[cur_target] = res
        return res
    
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # 改进的递归方法
        self.dp = [1] + [-1] * target
        return self.helper(nums, target)
  ```
  思考？？这种方法只能判断有几种组成方法，如果要找到具体每种方法是如何构成的，该怎么做？？  [39. Combination Sum]系列待补充
  
  * [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/)
  ```python
  class Solution(object):    
    def bag_01(self, nums, target):
        size = len(nums)
        dp = [0 for _ in range(target+1)]
        for i in range(1, size+1):
            for j in range(target, 0, -1):
                if j - nums[i-1] >= 0 and dp[j-nums[i-1]] + nums[i-1] > dp[j]:
                    dp[j] = dp[j-nums[i-1]] + nums[i-1]
                if dp[j] == target:
                    return True
        return False
    
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        total = sum(nums)
        
        if total % 2:
            return False
        target = total // 2
        # 0-1背包问题，这个背包容量为target，且必须被填满  
        return self.bag_01(nums, target)
        
  ```
  
  * [474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/)
  ```python
  class Solution(object):
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        # 二维费用的背包问题
        zeros = []
        ones = []
        for s in strs:
            zeros.append(s.count('0'))  # m
            ones.append(s.count('1'))   # n
         
        size = len(strs)
        
        dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
        
        for i in range(1, size+1):
            for j in range(n, ones[i-1]-1, -1):
                for k in range(m, zeros[i-1]-1, -1):
                    dp[j][k] = max(dp[j][k], dp[j-ones[i-1]][k-zeros[i-1]] + 1)
                        
        return dp[n][m]
  ```
  本题可以看成是二维背包费用的问题：0和1的个数是背包的两个参数（容量和体积），每个str中拥有的0和1的个数看做是对应物品的重量和体积，每个物品的价值都是1，求可以放入背包的物品的最大价值。与前面不同的是，此处的变量会有0的存在，导致二层和三层循环的终止应该是到0； 代码中简化了这里的写法，建议：背包问题，如果用降维空间的写法时，遍历的终止条件按照当前写法，不要写到0然后再在后面判断j和k是否大于对应的物品的重量和体积。
  
  * [494. Target Sum](https://leetcode.com/problems/target-sum/description/)
  ```python
  class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S: int
        :rtype: int
        """
        # 转化为0-1背包问题,寻找和为(S+sum(nums))//2 的组成个数
        # 状态转移方程：dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]
        
        summ = sum(nums)
        if summ < S or (S + summ) % 2:
            return 0
        
        target = (S + summ) // 2
        dp = [1] + [0] * target
        size = len(nums)
        for i in range(1, size+1):
            for j in range(target, nums[i-1]-1, -1):
                dp[j] += dp[j-nums[i-1]]
                
        return dp[target] 
  ```
  思路： 设nums中符号为+的数字，组成的集合为P; 符号为-的数字，组成的集合为N，则： 
  > sum(P) - sum(N) = S 且sum(P) + sum(N) = sum(nums);
  所以：sum(P)=(S + sum(nums) )/2
  
  因此该问题可以看成一个 0-1背包问题，从给定的 nums[] 中选出一个子集，如果其和等于 (S+ sum(nums)) // 2, 则这个子集符合题意，找到有多少个这样的子集即得到所有的方法。<br>
  用 dp[i][j] 表示前 i 个数的和为 j 的方法总数。第 i 个数可以选择放入背包或者不放入，则状态转移公式为:<br>
  dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]<br>
  简化后是：dp[j] = dp[j] + dp[i-nums[i]]
  
## 分割整数
* [91. Decode Ways](https://leetcode.com/problems/decode-ways/description/)
  ```python
  class Solution(object):
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        size = len(s)
        if size == 0 or s[0] == '0':
            return 0
        
        dp =[1,1] + [0 for _ in range(size-1)]
        # 从第二个字符开始
        for i in range(2, size+1):
            if int(s[i-2:i]) == 10 or int(s[i-2:i]) == 20:
                dp[i] = dp[i-2]
            elif 11 <= int(s[i-2:i]) <= 26:
                dp[i] = dp[i-1] + dp[i-2]
            elif s[i-1] != '0':
                dp[i] = dp[i-1]
            else:
                return 0
        print(dp)
        return dp[size]
        
  ```
  思路：用dp[i]表示前i个字符可以解码的个数，对于第i个字符，求其dp[i]的时候,有三种情况：<br>
  1. 第i个字符既可以当做一位数去解码，也可以和前面一个字符一起，当做两位数去解码： int(s[i-1:i+1]]) 取值在[11, 26]之间且不等于20， s[i-1:i+1]] dp[j] = dp[j-1] + dp[j-2] <br> 
  2. 第i个字符只能和前面一个字符一起，当做两位数去解码：int(s[i-1:i+1]]) == 10 or 20  dp[j] = dp[j-2] <br>
  3. 第i个字符只能当做一位数去解码：s[i] != '0'  dp[j] = dp[j-1]<br>
  4. 当前解码失败：其他情况，比如s[i] == 0，s[i-1] 也为0，直接返回0
  
* [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/description/)
 ```python

  import math
class Solution(object):
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        # dp[i]表示组成数字i的最小完全平方数的个数
        maxint = float('inf')
        dp = [0] + [maxint for _ in range(n)]
        
        for i in range(1, n+1):
            for j in range(1, int(math.sqrt(i))+1):
                dp[i] = min(dp[i], dp[i- j*j] + 1)
                
        return dp[n]
  ```
动态规划方法：dp[i]表示可以组成数字i的最小平方数的个数，那么对于i，求解dp[i]的时候，从1开始遍历int(sqrt(i))，这些数的平方可以组成dp[i] <br>
状态转移方程为：dp[i] = min(dp[i], dp[i-j * j]) 

## 数组区间
* 子数组最大和：[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)
  ```python
  class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0 
        res = nums[0]
        size = len(nums)
        # dp[i]表示以i结尾的最大子区间的和
        dp = [0 for _ in range(size+1)]
        for i in range(1, size+1):
            dp[i] = max(dp[i-1]+nums[i-1], nums[i-1])
            res = max(res, dp[i])
        return res
        
  ```
  dp[i]的计算，要么是将nums[i]加进来（dp[i] = dp[i-1] + nums[i]），要么不加（dp[i] = nums[i]），取二者最大值即可.同时用一个变量保存全局最大值,空间可以优化
  
* 子数组最大积：[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)
```python
class Solution(object):
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 无脑更新最大值和最小值
        size = len(nums)
        # dp_max和dp_min分别存储以i结尾子数组的最大值和最小值
        dp_max = [nums[0]] + [0 for _ in range(size-1)]
        dp_min = [nums[0]] + [0 for _ in range(size-1)]
        res = nums[0]
        
        for i in range(1, size):
            dp_max[i] = max(dp_max[i-1] * nums[i], dp_min[i-1] * nums[i], nums[i] )
            dp_min[i] = min(dp_max[i-1] * nums[i], dp_min[i-1] * nums[i], nums[i] )
            res = max(res, dp_max[i])
        return res
```
思路：用两个dp数组，其中dp_max[i]表示子数组[0, i]范围内并且一定包含nums[i]数字的最大子数组乘积，dp_min[i]表示子数组[0, i]范围内并且一定包含nums[i]数字的最小子数组乘积，初始化时dp_max[0]和dp_min[0]都初始化为nums[0]，其余都初始化为0。那么从数组的第二个数字开始遍历，此时的最大值和最小值只会在这三个数字之间产生，即dp_min[i-1] * nums[i]，dp_max[i-1] * nums[i]，和 nums[i]。用三者中的最大值来更新dp_max[i]，用最小值来更新dp_min[i]，然后用dp_max[i]来更新结果res即可，由于最终的结果不一定会包括nums[n-1]这个数字，所以dp_max[n-1]不一定是最终解，不断更新的结果res才是<br>

优化空间：
```python
class Solution(object):
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        mmax = mmin = res = nums[0]
        
        for i in range(1, len(nums)):
            lastmax = mmax
            mmax = max(lastmax * nums[i], mmin * nums[i], nums[i] )
            mmin = min(lastmax * nums[i], mmin * nums[i], nums[i] )
            res = max(res, mmax)
            print(mmax, mmin, res)
        return res
```
之所以需要一个lastmax是因为更新mmax之后，在计算mmin的时候用到的mmax不是上一个数的mmax，而是更新后的mmax

* 数组区间和：[303. Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/)
```python
class NumArray(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.dp = nums  # dp直接存储nums的数字，不初始化为0了
        for i in range(1, len(nums)):
            self.dp[i] += self.dp[i-1]
        
    def sumRange(self, i, j):
        """
        :type i: int
        :type j: int
        :rtype: int
        """
        if i > 0:
            return self.dp[j] - self.dp[i-1] 
        else:
            return self.dp[j]

# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)
```
用dp[i]存储到nums[i]之前的数字之和，不能直接去计算前i个数和前j个数的和，会超时

## 最长递增子序列(注意时间复杂度低的方法)
* 子序列：已知一个序列 {S1, S2,…,Sn} ，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个子序列。
* 递增子序列：如果在子序列中，当下标 ix > iy 时，Six > Siy，称子序列为原序列的一个递增子序列。
* (300. Longest Increasing Subsequence)[https://leetcode.com/problems/longest-increasing-subsequence/description/]
```python
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        size = len(nums)
        # dp[i] 表示到第 i 个数的最长递增子序列的长度
        dp = [1 for i in range(size)]
        res = 1
        for i in range(1, size):
            for j in range(i): 
                if nums[j] < nums[i]:
                    dp[i] = max(dp[j] + 1, dp[i])
            res = max(res, dp[i])   
        return res
```
dp[i]的求法：等于在i之前且小于nums[i]的那些数字中，dp值最大的，加1，时间复杂度是O(n^2)

```python
class Solution(object):
    def BinarySearch(self, arr, num):
        left, right = 0, len(arr)-1
        while left < right:
            mid = (left + right) // 2
            if arr[mid] < num:
                left = mid + 1
            else:
                right = mid
        return left
            
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        tails = [nums[0]]
        
        for i in range(len(nums)):
            if nums[i] < tails[0]:
                tails[0] = nums[i]
            elif nums[i] > tails[-1]:
                tails.append(nums[i])
            else:
                # 在tails数组中找到第一个不小于nums[i]的元素位置，并替换之
                index = self.BinarySearch(tails, nums[i])
                tails[index] = nums[i]

        return len(tails)
```
思路：暂时不明白为啥这样做可以求出结果。开辟一个数组tails，首先将nums[0]放进去，然后逐个遍历nums的元素，按照如下规则：<br>
1. 如果nums[i]小于tails的头元素：拿其去替换tails的头元素<br>
2. 如果nums[i]大于tails的尾元素，将其追加到tails数组中<br>
3. 如果nums[i]介于二者之间，二分查找(因为tails是有序的)tails，找出第一个不小于nums[i]的元素，将其替换成nums[i]<br>
最后tails数组的长度就是LIS序列的长度，但是tails数组中的元素并不是构成LIS序列的元素！<br>
时间复杂度为O(n * log(n))

## 最长公共子序列 与 最长公共子串
### 最长公共子序列
```python

def LongCommonSubsequence(s1, s2):
    size1 = len(s1)
    size2 = len(s2)
    dp = [[0 for _ in range(size2+1)] for _ in range(size1+1)]
    # 找长度
    maxlen = 0
    for i in range(1, size1+1):
        for j in range(1, size2+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    # 回溯，找最长公共子序列由哪些元素构成
    res = ''
    i, j = size1, size2
    while i > 0 and j > 0:
        if s1[i-1] == s2[j-1] and dp[i][j] == dp[i-1][j-1] + 1:
            res = res + s1[i-1]
            i, j = i-1, j-1
            continue
        if dp[i][j] == dp[i-1][j]:
            i, j = i-1, j
            continue
        if dp[i][j] == dp[i][j-1]:
            i, j = i, j-1
            continue
    return dp[size1][size2], res[::-1]
```
子序列不要求连续，只需要相对位置不变。用dp[i][j]记录以s1[i]结尾、和s2[j]结尾的公共子序列的长度,状态转移方程为：
1. 如果s1[i] == s2[j]，dp[i][j]的值要更新为前一段dp[i-1][j-1] 加1
2. 如果不等的话，dp[i][j]为max(dp[i-1][j], dp[i][j-1])即去掉当前的i或者j
最后求得的dp[size1][size2]即为最长的公共子序列<br>
要求得LCS由哪些元素组成，就从最后一个dp值回溯，判断dp值是由那个方向的求得的

### 最长公共子串
```python
def LongCommonSubstring(s1, s2):
    size1 = len(s1)
    size2 = len(s2)
    if not size1 or not size2:
        return 0, ''

    dp = [[0 for _ in range(size2+1)] for _ in range(size1+1)]
    res = ''
    for i in range(1, size1+1):
        for j in range(1, size2+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            if dp[i][j] > len(res):
                res = s1[i-dp[i][j]:i]
    return res, len(res)
```
子串要求字符必须是连续的，用dp[i][j]记录以s1[i]结尾、和s2[j]结尾的公共子串长度,状态转移方程为：
1. 如果s1[i] == s2[j]，dp[i][j]的值要更新为前一段dp[i-1][j-1] 加1
2. 如果不等的话，dp[i][j]为0
注意：dp中i与j的取值要与命名时的size1和size2对应，否则当两个s长度不同的时候会越界

## 最长回文子串 与 最长回文子序列
### [最长回文子串： 5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/)
```python
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        # dp[i][j]存储nums[i-j]之间（包括两端）是否是回文串
        size = len(s)
        dp = [[0 for _ in range(size)] for _ in range(size)]
        # left和right记录最长回文串的边界
        left = 0
        right = 0
        for i in range(size):
            for j in range(0, i+1):
                if j == i:
                    dp[j][i] = 1
                elif j == i - 1:
                    dp[j][i] = (s[i] == s[j])
                else:
                    dp[j][i] = (s[i] == s[j] and dp[j+1][i-1])
                if dp[j][i] and i-j > right - left:
                    left, right = j, i
        return s[left:right+1]
                
```
解法一：动态规划：dp[i][j]的更新规则：
1. 如果i==j，说明是同一个字符，取1；
2. 如果j+1==i，说明i和j是相邻的，只需要判断二者是否相同;
3. 其他情况，说明i和j之间隔有其他数字，只有在二者相同且i-1和j+1之间的字符串是回文串的情况下，取1
注意：给定一个i，j只能从0-i去求，不然如果从i之后的求，用到的i+1值因为还没求出来，会恒为0

```python
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        size = len(s)
        if size < 2:
            return s
        
        res = ''
        for i in range(size):
            left = right = i
            while right < size-1 and s[right] == s[right+1]:
                right += 1
            while left > 0  and right < size-1 and s[left-1] == s[right+1]:
                left -= 1
                right += 1
            # 更新最长序列
            if right-left + 1 > len(res):
                res = s[left: right+1]
        return res
```
解法二：中心扩展：逐一遍历 s 中的每一个字符，并比较其与后面一个字符，如果相等的话，则先找到这一对相邻的字符，再向左右扩展

### [最长回文子序列：516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)
```python
class Solution(object):
    def longestPalindromeSubseq(self, s):
        """
        :type s: str
        :rtype: int
        """
        size = len(s)
        if size < 2:
            return size
        res = 0
        # dp[i][j]表示i-j之间最长回文串的长度
        dp = [[0 for _ in range(size)] for _ in range(size)]
        for i in range(size):
            dp[i][i] = 1
            for j in range(i-1, -1, -1):
                if s[i] == s[j]:
                    dp[i][j] = dp[i-1][j+1] + 2
                else:
                    dp[i][j] = max(dp[i][j+1], dp[i-1][j])
                res = max(res, dp[i][j])
        return res              
```
思路：dp[i][j]取值规则：
1. 如果s[i] == s[j], dp[i][j] = dp[i-1][j+1] + 2
2. 否则，dp[i][j] 取去掉i或者j之中的最大值
注意：因为在求dp[i][j]的时候会用到dp[i][j+1]，所以对于给定的i，j要倒序

```python
class Solution(object):
    def helper(self, s, i, j, dp):
        if dp[i][j] != -1:
            return dp[i][j]
        if i > j:
            return 0
        if i == j:
            return 1 
        if s[i] == s[j]:
            dp[i][j] = self.helper(s, i+1, j-1, dp) + 2
        else:
            dp[i][j] = max(self.helper(s, i+1, j, dp), self.helper(s, i, j-1, dp))
        return dp[i][j]
    
    def longestPalindromeSubseq(self, s):
        """
        :type s: str
        :rtype: int
        """
        # 递归方法
        # dp数组是保存求得的结果，用到的时候直接查表，防止超时
        size = len(s)
        if size < 2:
            return size
        
        dp = [[-1 for _ in range(size)] for _ in range(size)]
        return self.helper(s, 0, size-1, dp)
```
解法二：递归方法，跟解法1差别不大

## 矩阵路径（从矩阵的最上角走到右下角）
* [62. Unique Paths](https://leetcode.com/problems/unique-paths/description/)
```python
class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        # dp[i][j]表示到[i,j]格子的方法数
        dp = [[1 for _ in range(n)] for _ in range(m)]
        # 填充dp
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]
```
如果dp初始化为全0的话，需要单独对第一行和第一列的元素修改为1，后面遍历的时候都是要修改的，所以可全初始化为1，这样不用再单独修改。

* [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/description/)
```python
class Solution(object):
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        # dp[i][j]表示到第[i,j]个格子有几种办法
        dp = [[0 for _ in range(n)] for _ in range(m)]
        
        # 第一列，因为只能从上往下走，所以只要有一个为1，后面的都走不了
        for i in range(m):
            if obstacleGrid[i][0] == 1:
                break
            else:
                dp[i][0] = 1
        # 同理，第一行
        for j in range(n):
            if obstacleGrid[0][j] == 1:
                break
            else:
                dp[0][j] = 1
        # 填充dp    
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] != 1:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
  
        return dp[m-1][n-1]
```
* [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/description/)
```python

```
   
   
