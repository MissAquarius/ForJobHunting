<!-- GFM-TOC -->
* <a href="#比较类排序">比较类排序</a>
  * <a href="#交换排序">交换排序</a>
    * <a href="#冒泡排序">冒泡排序</a>
    * <a href="#快速排序">快速排序</a>
  * <a href="#插入排序">插入排序</a>
    * <a href="#简单插入排序">简单插入排序</a>
    * <a href="#希尔排序">希尔排序</a>
  * <a href="#选择排序">选择排序</a>
    * <a href="#简单选择排序">简单选择排序</a>
    * <a href="#堆排序">堆排序</a>
  * <a href="#归并排序">选择排序</a>
    * <a href="#二路归并排序">二路归并排序</a>
    * <a href="#多路归并排序">多路归并排序</a>
* <a href="#非比较类排序">非比较类排序</a>
  * <a href="#计数排序">计数排序</a>
  * <a href="#基数排序">基数排序</a>
  * <a href="#桶排序">桶排序</a>
<!-- GFM-TOC -->


## <a name="比较类排序">比较类排序</a>
通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序

## <a name="交换排序">交换排序</a>
通过不断交换元素的位置，使其按照顺序排列
### <a name="冒泡排序">冒泡排序</a>
将相邻两个元素依次比较，如果顺序不对，就交换。一次冒泡的过程就是将数组中最大数移到末尾。
代码说明：外层循环控制冒泡次数，内存循环控制每次相邻元素的比较与交换。

```python

def bubble_sort(arr):
    length = len(arr)
    for i in range(length):
        for j in range(length-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

 ```
 * 改进1：提前终止冒泡过程，如果一次冒泡过程，没有发生元素交换，则所有数均已排好，可提前终止
 ```python
 
 def bubble_sort1(arr):
    length = len(arr)
    for i in range(length):
        flag = True
        for j in range(length-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                flag = False
        if flag:
            break

    return arr
 ```
 * 改进2：记录每次冒泡过程中最后发生交换的位置，该位置后面已经排好序，下次冒泡只需遍历该位置之前的数组
```python

def bubble_sort2(arr):
    length = len(arr)
    lastchange = length - 1
    for i in range(length):
        flag = True
        for j in range(lastchange):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                Lastchange = j
                flag = False
        if flag:
            break
    return arr
    
```
* 一共执行了n次冒泡，每次冒泡比较次数为 n-i，因此时间复杂度为O(n^2)；没有开辟额外空间，空间复杂度是O(1)

### <a name="快速排序">快速排序</a>
* 思想：快速排序是平均速度最快的一种排序方法。采用分治思想，举例：以第一个数 arr[0] 作为基准，通过一趟排序将数据分成两部分，比 arr[0] 小的数排在左边，比 arr[0] 大的数排在右边，再对这两个部分进行快排。所有序列长度为1时则序列已排好序。


```python

def quick_sort(arr, left, right):

    if left >= right:
        return arr
    key = arr[left]
    low = left
    high = right

    while left < right:
        while left < right and arr[right] >= key:
            right -= 1
        arr[left] = arr[right]
        while left < right and arr[left] <= key:
            left += 1
        arr[right] = arr[left]
    arr[left] = key

    quick_sort(arr, low, left - 1)
    quick_sort(arr, left + 1, high)

    return arr
    
```
* 时间复杂度：取决于所选择的基准元素：
  * 最好的情况：如果每次选择的基准元素都是当前子序列的中间数，那么该数在一次快速排序过程中的最终位置就在子序列的中间，这样就把原来的子序列拆分成两个长度基本相等的子序列，排序最快，此时时间复杂度为O(nlogn)
  * 最坏的情况：如果每次选择的基准元素都是当前子序列中的最值，那么一次快速排序之后，该序列被分为一个空序列和一个长度-1的序列，退化为冒泡排序，复杂度O(n^2)
* 空间复杂度：由于采用递归，需要栈空间暂存数据，栈的深度最好的情况下是logn+1，最坏情况下是n，因此空间复杂度是 O(n)

* 改进：三数取中法
在最差情况下，如序列是正序或者逆序时，每次选到的基准元素都是首元素或尾元素，这是并没有起到划分的作用，导致快排的效率极速退化；
因此可以考虑将基准元素取为：在序列的第一，中间，最后三个值里面选一个中间值出来作为枢轴，保证每次划分接近均等


## <a name="插入排序">插入排序</a>
对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

### <a name="直接插入排序">直接插入排序</a>
基本思想：顺序地把待排序序列中的每个记录按照大小插入到已经排序的序列的适当位置
如：在排序开始，默认第一个元素是有序的，然后对于第二个元素，与第一个元素比较交换; 之后的arr[i]与前i-1个元素进行比较，如果arr[i]比其小，就将其往后移，将arr[i]插入到合适位置
```python
def insert_sort(arr):
    length = len(arr)
    for i in range(1, length):
        j = i - 1
        temp = arr[i]
        while j >= 0 and arr[j] > temp:
            arr[j + 1] = arr[j]
            j -= 1
        # 退出循环后，多减了1
        arr[j + 1] = temp

    return arr
```
* 时间复杂度：O(n^2)
* 空间复杂度：只需要一个额外变量temp，空间复杂度是常数级O(1)
* 改进：折半插入排序，将折半查找的技术引入到选择插入点中，利用 前面的序列已经排好序 这个条件
```python
def half_merge_sort(arr):
    length = len(arr)
    for i in range(1, length):
        temp = arr[i]
        low = 0
        high = i-1

        while low <= high:
            mid = (low + high) // 2
            if arr[mid] > temp:
                high = mid - 1
            else:
                low = mid + 1

        # low > high,插入的合适位置为high + 1
        for j in range(i-1, high, -1):
            arr[j+1] = arr[j]
        arr[j] = temp
        
    return arr

```
### <a name="希尔排序">希尔排序</a>
希尔排序是简单插入排序的改进版，又称“缩小增量排序”。首先取间隔为n的元素为一组，对组内的元素实行简单插入排序，然后将所有的组合并。之后将间隔减小，再次按照上述步骤取数分组排序。直到间隔减小为1时，取所有的元素为一组，由于数据有序性比较高，所以相对于简单插入排序来说，效率会高。
改进点在于：对于间隔较远的数，在前期分组中就按照顺序交换排好了，减少后期移次数。

```python
# -*- coding:utf-8 -*-


def shell_sort(arr, span):
    i = 0
    while i < span:
        for j in range(0, len(arr), span):
            key = arr[j] 
            k = j - span
            while k > -1 and key < arr[k]:
                arr[k+span] = arr[k]
                k -= span
            arr[k+span] = key
        i += 1
    return arr


if __name__ == '__main__':
    arr = [10, 1, 4, 5, 2, 1, 9, 9, 8]
    span = len(arr)
    # 存储间隔列表
    span_list = []
    while span > 1:
        span = span // 2
        span_list.append(span)
    
    for span in span_list:
        shell_sort(arr, span)
        
    print(arr)

```
* 时间复杂度：O(n*(logn)^2)
* 空间复杂度：O(1)


## <a name="选择排序">选择排序</a>
基本思想：不断地从待排序的序列中选择关键字最小的记录当放到已排序的序列的后面，直到待排序的序列长度为0

### <a name="简单选择排序">简单选择排序</a>
* 从待排序的所有记录中，选择最小的元素，与原始序列中的第一个元素交换位置，然后从去掉第一个元素的序列中选择最小的，将其与原始序列中的第二个元素交换位置，重复。
```python
def select_sort(arr):
    for i in range(0, len(arr)-1): ## 注意右边界，如果待排序序列中只剩一个元素，那它一定是最大的，最后一个不需要排
        minindex = i
        for j in range(i, len(arr)):
            if arr[j] < arr[minindex]:
                minindex = j
        arr[i], arr[minindex] = arr[minindex], arr[i]
    return arr
```
* 备注：外循环控制排序次数，内循环控制一次排序过程中，寻找最小值
* 时间复杂度：O(n^2)
* 空间复杂度：只需一个额外的空间存储minindex，因此是O(1)

### <a name="堆排序">堆排序</a>


## <a name="归并排序">归并排序</a>
归并排序是建立在归并操作上的一种排序算法。该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列。即先使每个子序列有序，再使子序列段间有序。

### <a name="二路归并排序">二路归并排序</a>
基本思想：将n个记录的原始序列看做是n个长度为1的子序列。从第一个子序列开始，把相邻的子序列两两合并，等到n//2（向上取整）个序列长度为1或者2的序列。然后对一次归并排序后的子序列按照上述方法再次归并。重复直到最后得到一个长度为n的子序列，排序结束。
* 
```python
# -*- coding:utf-8 -*-

# 一次归并操作
def merge(arr, size):
    length = len(arr)
    temp = []
    lb1 = 0
    
    while lb1 + size < length:  # 第二段存在
        # 确定四个指针的位置
        lb2 = lb1 + size
        ub1 = lb2 - 1
        if lb2 + size - 1 < length:
            ub2 = lb2 + size - 1
        else:
            ub2 = length - 1

        # 对两段归并
        i, j = lb1, lb2
        while i <= ub1 and j <= ub2:
            if arr[i] < arr[j]:
                temp.append(arr[i])
                i += 1
            else:
                temp.append(arr[j])
                j += 1

        if i > ub1:
            temp.extend([arr[k] for k in range(j, ub2 + 1)])  # temp.extend(arr[j:ub2 + 1])
        else:
            temp.extend([arr[k] for k in range(i, ub1 + 1)])

        lb1 = ub2 + 1
        
    temp.extend([arr[k] for k in range(lb1, length)])
    return temp

if __name__ == '__main__':
    arr = [10, 1, 4, 5, 2, 1, 9, 9, 8]

    size = 1
    while size < len(arr):
        arr = merge(arr, size)
        size *= 2
    print(arr)

```
```python
# -*- coding:utf-8 -*-
# 递归写法

def merge(arr1, arr2):
    res = []
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            res.append(arr1[i])
            i += 1
        else:
            res.append(arr2[j])
            j += 1
    if i < len(arr1):
        res.extend(arr1[i:])
    else:
        res.extend(arr2[j:])
    return res


def mergesort(arr):
    if len(arr) <= 1: # 递归终止条件：分为每一个长度为1的子序列
        return arr
    mid = len(arr) // 2
    left = mergesort(arr[:mid])
    right = mergesort(arr[mid:])
    
    return merge(left, right)


if __name__ =='__main__':
    arr = [10, 1, 4, 5, 2, 1, 9, 9, 8]
    print(mergesort(arr))

```
* 注意：extend那里写法
* 时间复杂度：O(n*logn)
* 空间复杂度：O(n)



## <a name="非比较类排序">非比较类排序</a>
不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序
## <a name="计数排序">计数排序</a>
## <a name="基数排序">基数排序</a>
## <a name="桶排序">桶排序</a>


