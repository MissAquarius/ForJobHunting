<!-- GFM-TOC -->
* <a href="#比较类排序">比较类排序</a>
  * <a href="#交换排序">交换排序</a>
    * <a href="#冒泡排序">冒泡排序</a>
    * <a href="#快速排序">快速排序</a>
  * <a href="#插入排序">插入排序</a>
    * <a href="#简单插入排序">简单插入排序</a>
    * <a href="#希尔排序">希尔排序</a>
  * <a href="#选择排序">选择排序</a>
    * <a href="#简单选择排序">简单选择排序</a>
    * <a href="#堆排序">堆排序</a>
  * <a href="#归并排序">选择排序</a>
    * <a href="#二路归并排序">二路归并排序</a>
    * <a href="#多路归并排序">多路归并排序</a>
* <a href="#非比较类排序">非比较类排序</a>
  * <a href="#计数排序">计数排序</a>
  * <a href="#基数排序">基数排序</a>
  * <a href="#桶排序">桶排序</a>
<!-- GFM-TOC -->


## <a name="比较类排序">比较类排序</a>
通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序
## <a name="交换排序">交换排序</a>
通过不断交换元素的位置，使其按照顺序排列
### <a name="冒泡排序">冒泡排序</a>
将相邻两个元素依次比较，如果顺序不对，就交换。一次冒泡的过程就是将数组中最大数移到末尾。
代码说明：外层循环控制冒泡次数，内存循环控制每次相邻元素的比较与交换。
一共执行了n次冒泡，每次冒泡比较次数为 n-i，因此时间复杂度为O(n2)；没有开辟额外空间，空间复杂度是O(1)
```python

def bubble_sort(arr):
    length = len(arr)
    for i in range(length):
        for j in range(length-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

 ```
 * 改进1：提前终止冒泡过程，如果一次冒泡过程，没有发生元素交换，则所有数均已排好，可提前终止
 ```python
 
 def bubble_sort1(arr):
    length = len(arr)
    for i in range(length):
        flag = True
        for j in range(length-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                flag = False
        if flag:
            break

    return arr
 ```
 * 改进2：记录每次冒泡过程中最后发生交换的位置，该位置后面已经排好序，下次冒泡只需遍历该位置之前的数组
```python

def bubble_sort2(arr):
    length = len(arr)
    lastchange = length - 1
    for i in range(length):
        flag = True
        for j in range(lastchange):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                Lastchange = j
                flag = False
        if flag:
            break
    return arr
    
```
### <a name="快速排序">快速排序</a>
快速排序采用分治思想，以第一个数 arr[0] 作为基准，通过一趟排序将数据分成两部分，比 arr[0] 小的数排在左边，比 arr[0] 大的数排在右边，
再对这两个部分进行快排。所有序列长度为1时则序列已排好序。
快速排序的平均时间复杂度为 O(nlogn)，空间复杂度 O(n)
就一次快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的是递归调用，因为每次递归就要保存一些数据；

最优的情况下时间复杂度为：O(logn) ；每一次都平分数组的情况
最差的情况下时间复杂度为：O( n2 ) ；退化为冒泡排序的情况
大小相同的元素可能会交换顺序，因此快速排序是不稳定排序

快速排序的总体平均效率是最好的，但并不是任何时刻都最优。 最差的情况是如果数组已经排好序，时间复杂度会变为 O(n2)。
```python

def quick_sort(arr, left, right):

    if left >= right:
        return arr
    key = arr[left]
    low = left
    high = right

    while left < right:
        while left < right and arr[right] >= key:
            right -= 1
        arr[left] = arr[right]
        while left < right and arr[left] <= key:
            left += 1
        arr[right] = arr[left]
    arr[left] = key

    quick_sort(arr, low, left - 1)
    quick_sort(arr, left + 1, high)

    return arr
    
```
## <a name="插入排序">插入排序</a>

### <a name="简单插入排序">简单插入排序</a>
### <a name="希尔排序">希尔排序</a>

## <a name="选择排序">选择排序</a>
### <a name="简单选择排序">简单选择排序</a>
### <a name="堆排序">堆排序</a>

## <a name="归并排序">归并排序</a>
### <a name="二路归并排序">二路归并排序</a>
### <a name="多路归并排序">多路归并排序</a>
## <a name="非比较类排序">非比较类排序</a>
不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序
## <a name="计数排序">计数排序</a>
## <a name="基数排序">基数排序</a>
## <a name="桶排序">桶排序</a>


