<!-- GFM-TOC -->
* <a href="#比较类排序">比较类排序</a>
  * <a href="#交换排序">交换排序</a>
    * <a href="#冒泡排序">冒泡排序</a>
    * <a href="#快速排序">快速排序</a>
  * <a href="#插入排序">插入排序</a>
    * <a href="#简单插入排序">简单插入排序</a>
    * <a href="#希尔排序">希尔排序</a>
  * <a href="#选择排序">选择排序</a>
    * <a href="#简单选择排序">简单选择排序</a>
    * <a href="#堆排序">堆排序</a>
  * <a href="#归并排序">选择排序</a>
    * <a href="#二路归并排序">二路归并排序</a>
    * <a href="#多路归并排序">多路归并排序</a>
* <a href="#非比较类排序">非比较类排序</a>
  * <a href="#计数排序">计数排序</a>
  * <a href="#基数排序">基数排序</a>
  * <a href="#桶排序">桶排序</a>
<!-- GFM-TOC -->


## <a name="比较类排序">比较类排序</a>
通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序
## <a name="交换排序">交换排序</a>
通过不断交换元素的位置，使其按照顺序排列
### <a name="冒泡排序">冒泡排序</a>
将相邻两个元素依次比较，如果顺序不对，就交换。一次冒泡的过程就是将数组中最大数移到末尾。
代码说明：外层循环控制冒泡次数，内存循环控制每次相邻元素的比较与交换。
一共执行了n次冒泡，每次冒泡比较次数为 n-i，因此时间复杂度为O(n2)；没有开辟额外空间，空间复杂度是O(1)
```python

def bubble_sort(arr):
    length = len(arr)
    for i in range(length):
        for j in range(length-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

 ```
 * 改进1：提前终止冒泡过程，如果一次冒泡过程，没有发生元素交换，则所有数均已排好，可提前终止
 ```python
 
 def bubble_sort1(arr):
    length = len(arr)
    for i in range(length):
        flag = True
        for j in range(length-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                flag = False
        if flag:
            break

    return arr
 ```
 * 改进2：记录每次冒泡过程中最后发生交换的位置，该位置后面已经排好序，下次冒泡只需遍历该位置之前的数组
```python

def bubble_sort2(arr):
    length = len(arr)
    lastchange = length - 1
    for i in range(length):
        flag = True
        for j in range(lastchange):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                Lastchange = j
                flag = False
        if flag:
            break
    return arr
    
```
### <a name="快速排序">快速排序</a>
快速排序采用分治思想，以第一个数 arr[0] 作为基准，通过一趟排序将数据分成两部分，比 arr[0] 小的数排在左边，比 arr[0] 大的数排在右边，再对这两个部分进行快排。所有序列长度为1时则序列已排好序。
快速排序的平均时间复杂度为 O(nlogn)，空间复杂度 O(n)，就一次快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的是递归调用，因为每次递归就要保存一些数据；

最优的情况下时间复杂度为：O(logn) ；每一次都平分数组的情况
最差的情况下时间复杂度为：O( n2 ) ；退化为冒泡排序的情况（比如选取的基准元素正好是整个序列最值）

快速排序的总体平均效率是最好的，但并不是任何时刻都最优。 最差的情况是如果数组已经排好序，时间复杂度会变为 O(n2)。
```python

def quick_sort(arr, left, right):

    if left >= right:
        return arr
    key = arr[left]
    low = left
    high = right

    while left < right:
        while left < right and arr[right] >= key:
            right -= 1
        arr[left] = arr[right]
        while left < right and arr[left] <= key:
            left += 1
        arr[right] = arr[left]
    arr[left] = key

    quick_sort(arr, low, left - 1)
    quick_sort(arr, left + 1, high)

    return arr
    
```
* 改进：三数取中法
在最差情况下，如序列是正序或者逆序时，每次选到的基准元素都是首元素或尾元素，这是并没有起到划分的作用，导致快排的效率极速退化；
因此可以考虑将基准元素取为：在序列的第一，中间，最后三个值里面选一个中间值出来作为枢轴，保证每次划分接近均等

## <a name="插入排序">插入排序</a>
对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

### <a name="简单插入排序">简单插入排序</a>
在排序开始，默认第一个元素是有序的，然后对于第二个元素，与第一个元素比较交换; 之后的arr[i]与前i-1个元素进行比较，如果arr[i]比其小，就将其往后移，将其插入到合适位置
```python
def insert_sort(arr):
    length = len(arr)
    for i in range(1, length):
        j = i - 1
        temp = arr[i]
        while j >= 0 and arr[j] > temp:
            arr[j + 1] = arr[j]
            j -= 1
        # 退出循环后，多减了1
        arr[j + 1] = temp

    return arr
```
### <a name="希尔排序">希尔排序</a>
希尔排序是简单插入排序的改进版，又称“缩小增量排序”。首先取间隔为n的元素为一组，对组内的元素实行简单插入排序，然后将所有的组合并。之后将间隔减小，再次按照上述步骤取数分组排序。直到间隔减小为1时，取所有的元素为一组，由于数据有序性比较高，所以相对于简单插入排序来说，效率会高。
改进点在于：对于间隔较远的数，在前期分组中就按照顺序交换排好了，减少后期移次数。

```python
## 待补充
```

## <a name="选择排序">选择排序</a>

### <a name="简单选择排序">简单选择排序</a>

### <a name="堆排序">堆排序</a>

## <a name="归并排序">归并排序</a>
归并排序是建立在归并操作上的一种排序算法。该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列。即先使每个子序列有序，再使子序列段间有序。

### <a name="二路归并排序">二路归并排序</a>
若将两个有序表合并成一个有序表，称为2-路归并
* 首先将数组分为长度为1的
```python

```
### <a name="多路归并排序">多路归并排序</a>
## <a name="非比较类排序">非比较类排序</a>
不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序
## <a name="计数排序">计数排序</a>
## <a name="基数排序">基数排序</a>
## <a name="桶排序">桶排序</a>


