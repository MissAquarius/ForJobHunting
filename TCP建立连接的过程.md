## TCP简介
* TCP（传输控制协议）：是一种面向连接的、可靠的、基于字节流的传输层协议
* 在一个 TCP 连接中，仅有两方进行彼此通信，因此广播和多播不能用于 TCP
* TCP 使用校验和，确认和重传机制来保证可靠传输
* TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
* TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

## TCP三次握手与四次挥手
* 首先了解TCP的报文格式
![image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/TCP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F.png)

* 重要字段及意义
  * 原端口号（source port）-目的端口号(destination port)：同IP数据报中的源IP与目的IP，唯一确定一条TCP连接
  * 序列号(sequence number)：占4字节，TCP是面向字节流的，在一个TCP连接中传送的字节流的每一个字节都按顺序编号.如：传送1000个字节的字节流，其中每个字节都是有编号的，比如0-999，这里的序号是指发送的时候本报文段的第一个字节的序。
  * 确认号(acknowledgement number)：占4字节，是期望收到下一个报文段的第一个数据字节的序号。如果确认号为N，表示到序号N-1为止的所有的数据都已经正确收到
  * 首部长度(header length)：4位，首部长度也称为数据偏移，其代表的意思是本报文的数据起始处距离本报文段的起始处有多远，因为TCP首部中存在可选字段，所以首部长度不固定，所以这个字段是必要的，可以明确指出TCP报文的首部长度。因为其是按4字节为单位的，所以4位二进制数能表示的最大数是15，也就是首部最大长度是60字节
  * 保留(resv)：占6位，目前未使用，置0
  * 码元比特（Control Bits）：有6个控制位，其中包括：URG（Urgent，ACK(Acknowledgment),PSH(Push)，RST(Reset)，SYN，FIN；
    * ACK：确认号有效性标志，一旦一个连接被建立起来，该位就为1，请求连接的时候该位为0
    * SYN：取值1代表这是一个TCP三次握手的建立连接的包，取值为0就代表是其他包
    * FIN：传输数据结束标志
  * 窗口(window size)：占16个字节，这里的窗口不是指发送方的窗口，而是指接收端此时还能接收多少数据，因为接收方接收数据的缓冲区的大小是有限的。此处的窗口值是作为发送方设置其发送窗口大小的依据
  * 校验和(checksum)：占2个字节，校验首部和数据部分
  * 紧急指针(urgent pointer)：占2个字节，只有在URG=1(表示紧急数据需加速传递)的时候才有效
  
* TCP三次握手：
  * 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。
![image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)
    * 第一次握手：
客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。
发送完毕后，客户端进入 SYN_SEND 状态；
    * 第二次握手：
服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 
发送完毕后，服务器端进入 SYN_RCVD 状态。
    * 第三次握手
客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

* TCP四次挥手：
  * TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作。
![image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
    * 第一次挥手：
假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
发送完毕后，客户端进入 FIN_WAIT_1 状态。
    * 第二次挥手：
服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
    * 第三次挥手
服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。
    * 第四次挥手：
客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。
服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

## SYN攻击
* 什么是 SYN 攻击（SYN Flood）？
在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.
SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。
SYN 攻击是一种典型的 DoS/DDoS 攻击。
* 如何检测 SYN 攻击？
检测 SYN 攻击非常的方便，当在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。
* 如何防御 SYN 攻击？
SYN攻击不能完全被阻止，除非将TCP协议重新设计。所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：
  * 缩短超时（SYN Timeout）时间
  * 增加最大半连接数
  *过滤网关防护
  * SYN cookies技术

## TCP与UDP的区别
  * UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次
  * UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。
  * UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。
  * UDP 支持多播和广播。
## 扩充：OSI七层模型中对应的协议（面试常问某个协议是属于哪一层？）
层次     | 功能     |  主要协议  
---------- | :----------- | :-----------
 应用层     | 文件传输，电子邮件，文件服务，虚拟终端  |HTTP，FTP，DNS，SMTP，Telnet 等   
 表示层     | 数据格式化，代码转换，数据加密   | 没有协议
 会话层     | 接触与建立与别的接点的联系  | 没有协议  
 传输层     | 提供端对端的借口    | TCP，UDP
 网络层     | 为数据包选择路由 | IP，ICMP，OSPF，RIP等
 数据链路层  | 传输有地址的帧以及错误检测功能 | PPP，ARP等
 物理层     | 以二进制数据形式在物理媒体上传输数据 | ISO2110，IEEE802等 
