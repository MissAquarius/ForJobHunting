# 测试理论基础
* 测试分类：
  1. 按测试对象：黑盒、白盒、灰盒
  2. 按测试手段：手工、自动化
  3. 按整体-局部(开发阶段): 单元、集成、系统、验收
  4. 按程序是否运行：静态测试，即文档测试（不执行代码），如文档评审、代码走查；动态测试，如黑白灰盒
   
* 黑盒测试：
  也称功能测试，它是通过测试来检测每个功能是否都能正常使用。 <br>
  方法： 等价类划分法、边界值分析法、错误推断法、因果图法、判定表法、判定树

* 白盒测试：
  白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试，需要全面了解程序内部逻辑结构、对所有逻辑路径进行测试。<br>
  方法：（覆盖程度由弱到强）
  1. 语句覆盖： 最基本的结构覆盖要求，设计出来的测试用例要保证程序中的每一个语句至少被执行一次。
  2. 判定覆盖： 也叫分支覆盖，要求选择足够的测试用例，使得程序中每个判定至少有一次为真值，有一次为假值，即：程序中的每个分支至少执行一次。
  3. 条件覆盖： 要求所设计的测试用例能使每个判定中的每一个条件都获得可能的取值，即每个条件至少有一次真值、有一次假值。
  4. 判定/条件覆盖：设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。
  5. 条件组合覆盖： 每个判定中条件结果的所有可能组合至少出现一次。
  6. 路径覆盖： 覆盖程序中所有可能的路径，最强的覆盖准则。
  
  包含关系：
  1. 满足 判定覆盖， 就满足 语句覆盖；
  2. 判定覆盖 和 条件覆盖没有没关系；
  3. 满足 条件覆盖 也不一定满足 语句覆盖 、判定覆盖
  4. 满足条件/判定覆盖的一定满足判定覆盖与条件覆盖
  5. 如果达到条件组合覆盖，就达到其上的四种
 
* 灰盒测试
  灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。

软件测试一般分为4个阶段：单元测试、集成测试、系统测试、验收测试
* 单元测试
  单元测试是对软件中的最小可测试单元（比如某个函数）进行检查和验证，由开发人员完成，属于白盒测试方法。<br>
  单元测试用于验证编码单元的正确性，单元测试的测试用例根据详细设计的结果来设计。<br>

  单元测试的策略： 逻辑覆盖、 循环覆盖、 同行评审、 桌前检查、 代码走查、 代码评审、 数据流分析 <br>
  python 中可以用 unittest 模块进行单元测试。 在Web开发过程中，单元测试实际上就是一些“断言”（assert）代码。 <br>

* 集成测试
  集成测试也叫组装测试或联合测试。在单元测试的基础上，将所有模块依据系统概要设计组装成为子系统或系统，进行集成测试。用于验证详细设计。    测试方法： 白盒测试、黑盒测试

* 系统测试
  将经过集成测试的软件，作为计算机系统的一部分，与系统中其他部分结合起来，在实际运行环境下进行一系列严格有效的测试，以发现软件潜在的问题，保证系统的正常运行。  测试方法：黑盒测试

  集成测试和系统测试之间的比较： 
  1. 测试内容：集成测试是测试各个单元模块之间的接口，系统测试是测试整个系统的功能和性能； 
  2. 测试角度：集成测试偏重于技术的角度进行测试，系统测试是偏重于业务的角度进行测试。

* 验收测试
验收测试是是部署软件之前的最后一个测试操作，确保所开发的软件产品符合用户的各项要求, 用于验证正确实现了需求，通常由用户、客户或其他授权机构决定是否接受系统。 测试方法：α测试、β测试；

* 面试题：测试用例由哪些组成？
  用例所属项目、模块（可选）、用例ID、 用例名称、前置条件、测试步骤、预期结果、测试人、测试结果、备注、优先级、执行方式（手动、自动）、测试目的、测试级别、参考信息、测试环境、用例撰写者以及执行者、


# BUG相关
* 严重等级：
  1. 致命： 主程序不通，系统无法运行等。如内存泄露、严重数值计算错误、易崩溃、功能与需求设计不符等
  2. 严重： 影响系统功能或操作、主要功能严重缺陷，但不影响系统稳定性。如功能未实现、功能报错、轻微计算失误
  3. 一般： 界面、性能缺陷。如边界条件下错误、大数据无响应等
  4. 建议： 易用性及建议性问题
* 生命周期：
  1. new: 新建 bug，未经评审需决定是否指派给开发人员进行修改
  2. open: 确认是需要修改的 bug，指派给开发人员
  3. fixed: 开发人员修改后，需回归测试验证
  4. delay: 暂时不需要修改的 bug，必须一些优化的意见
  5. closed: 经过测试人员回归验证后，关闭 bug
  6. reopen: 经验证后发现未修改完成，则重新打开，重新修改
* 包含的内容：
  Bug 标题 短描述、重现步骤--详细步骤、实际结果、预期结果、Bug 类型和严重程度、Bug 测试环境、附件

# 接口测试
一般分为：
1. 程序内部接口： 方法与方法之间、模块与模块之间的交互，供内部系统进行调用
2. 系统对外接口： 需要从别的网站或服务器获取资源信息，通过他们的 api

常见接口：
1. webService 接口：走 SOAP 协议通过 HTTP 传输，请求报文和返回报文都是 XML 格式，可以用 SoapUI、jmeter、loadrunner 等工具测试
2. HTTP API 接口： 走 HTTP 协议，通过路径区分调用方式，请求报文为 key-value 形式，返回报文为 json 串； 有 post 和 get 等方法，可以用 postman、RESTClient、jmeter、loadrunner 等工具测试

接口测试是测试系统组件间接口，主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。实际上是黑盒测试。<br>
重点: 检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。<br>
接口测试没有页面，通过接口规范文档上的调用地址、请求参数、拼接报文，然后发送请求，检查返回结果，只需测入参和出参。

* 接口组成
接口文档组成： 接口说明、调用 url、 请求方法、 请求参数（参数类型、说明）、返回参数说明

接口： 请求地址、请求方法、请求参数（入参、出参）、部分接口有请求头 header（存放校验信息，是否有权限请求服务器，如cookie）

* 为什么要做接口测试
1. 可以发现很多在页面上操作无法发现的 bug， 比如登陆的后端校验，防止使用抓包直接绕过前端校验，防止 SQL 注入
2. 检查系统的异常处理能力
3. 检查系统的安全性、稳定性

* 接口测试的方法
1. 接口请求报文拼接：传参方式, 用 key-value 或输入 json 串
2. post 和 get 请求
get 请求直接在浏览器输入，浏览器能够直接请求到的都是 get 请求； post 需要借助工具发送

* 接口用例设计：
1. 通过性验证：按照接口文档的参数等正常传入，看是否能返回正确结果
2. 参数组合：
3. 接口安全： 绕过验证、绕过身份授权、参数是否加密、密码安全规则等
4. 异常验证： 必填的参数不填、参数类型、入参长度

* 接口测试流程（同软件测试流程）
1. 需求评审，熟悉业务和需求
2. 测试接口文档，由开发提供接口文档
3. 根据文档写测试用例
4. 用例评审
5. 执行测试，查看接口返回的数据是否正确，是否与文档、数据库一致
6. 提交测试报告

# 性能测试（不熟悉）
* 性能测试： 通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。
* 关注的指标：
  * 资源指标： cpu 利用率、 内存利用率、 磁盘 IO、 网络带宽 
  * 系统指标： 并发用户数、 在线用户数、 平均响应时间、 事务成功率、 错误率
* 性能测试的类型
  * 基准测试：在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考
  * 负载测试：是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。
  * 压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。
  * 稳定性测试：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。
  * 并发测试：测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题

注意： 压力测试与负载测试区别
负载测试是通过改变系统负载方式、增加负载等来发现系统中所存在的性能问题。可以发现系统可能存在的性能瓶颈、内存泄漏、不能实时同步等问题。（比如增加用户访问数量）

压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。可以把压力测试看做负载测试的一种。主要关注系统的稳定性。（比如程序长时间运行，有稳定性测试和破坏性测试）

简单理解： 负载测试就是不断增加压力，进行测试。 压力测试就是最大负载下的测试。

# 兼容性测试
兼容性测试： 指对所设计程序与硬件、软件之间的兼容性的测试。
常见的有： 浏览器兼容性、分辨率兼容性、系统兼容性

# 软件相关
* 软件生命周期
  1. 软件计划与可行性研究阶段（问题定义、可行性研究）
  2. 需求分析阶段
  3. 软件设计阶段（概要设计和详细设计）
  4. 软件编码阶段
  5. 软件测试阶段
  6. 软件运行与维护阶段

* 五种开发周期模型
  * 瀑布模型
  一般情况下将其分为计划、需求分析、概要设计、详细设计、编码以及单元测试、测试、运行维护等几个阶段。瀑布模型的周期是环环相扣的。每个周期中交互点都是一个里程碑，上一个周期的结束需要输出本次活动的工作结果，本次的活动的工作结果将会作为下一个周期的输入。这样，当某一个阶段出现了不可控的问题的时候，就会导致返工，返回到上一个阶段，甚至会延迟下一个阶段。

  * V 模型
   V模型从整体上看起来，就是一个V字型的结构，由左右两边组成。它的重要意义在于，非常明确的表明了测试过程中存在的不同的级别，并且非常清晰的描述了这些测试阶段和开发阶段的对应关系。从左上到左下，再到右上，分别是：用户需求、需求分析、概要设计、详细设计、软件编码、单元测试、集成测试、系统测试、验收测试。

  * 原型模型
  原型化模型第一步就是创建一个快速原型，能够满足项目干系人与未来的用户可以与原型进行交互，再通过与相关干系人进行充分的讨论和分析，最终弄清楚当前系统的需求，进行了充分的了解之后，在原型的基础上开发出用户满意的产品。

  * 螺旋模型
  螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。

  * 敏捷开发（迭代模型）
  敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。采用"增量开发"来划分迭代，增量开发是软件的每个版本，都会新增一个用户可以感知的完整功能。增量开发加上迭代开发，才算真正的敏捷开发。

# 名词解释
* α测试与β测试
  * α测试： 由一个用户在开发环境下进行的测试，可以是公司内部的用户在模拟实际操作环境下进行的测试。 注意α测试不能由程序员或测试员完成。
  * β测试： 用户在不同场所进行测试。
  α测试和β测试都属于验收测试，α测试先于β测试执行

* 灰度测试（类似于A/B test）
在某项产品或应用正式发布前，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中的问题。

AB test 就是一种灰度发布方式，让一部分用户继续用 A，一部分用户开始用 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。

* 安卓调试： adb
  * adb devices； 检测连接到电脑的安卓设备（需要手机开了开发者模式）
  * adb pull 手机路径 本机路径；  从手机中拉取信息放到本地电脑
  * adb push 本机路径 手机路径； 从本地推送信息到手机上
  * adb shell 可以进入手机 的linux环境
  * adb logcat > 本机路径 ； 把手机的日志重定向到本机
  * adb install 给手机安装软件
* iOS调试
  * idevice_id -l ;显示当前所连接的设备
  * ideviceinstaller -u [udid] -i [xxx.ipa] ; 给指定连接的设备安装软件
  * ideviceinstaller -u [udid] -U [bundleld] ; 给指定连接的设备卸载软件

## 面试测试设计实例
* 测试一支笔
  * 界面：尺寸是否符合不同人群的习惯、色彩的搭配、形状、方便携带和存放、印刷的图案或者文字是否清晰
  * 功能测试： 笔筒的开合、笔芯的替换、写字顺滑度、出墨的快慢、自动铅笔的话还要判断一次出来的长度是否合适、握笔是否会滑、写出来的字多久能干、
  * 性能测试：长时间书写、使用寿命、壳子和笔尖多大的压力范围内可以正常写字、温度湿度等外界因素对笔的影响、长时间没盖盖子是否影响、
  * 安全测试：易燃易爆、皮肤身体损害、划到手、食用无毒、尖锐部位是否有保护
  * 兼容性测试：哪些纸上可以写出来字、笔芯匹配度
  * 探索性测试： 写过字的纸张泡水、气味是否刺鼻、和其他品牌的比较测试、在木板墙壁上书写

* 给一个登录界面都可以从哪些方面测试；
