## 网易游戏-测试
* py2和py3的的区别：
  * 编码：python2默认编码方式ASCII码（不能识别中文，要在文件头部加上  #-*- encoding：utf-8 -*-  指定编码方式）；python3默认编码方式unicode（可识别中文）
  * print函数，py2中加不加括号都可以，py3中必须加括号
  * input：py2中input()函数得到int类型，而raw_inpt()得到str类型; py3中input()得到str类型
  * range: py2中range()/xrange(); py3中range()
  * 整除：py2的除法，操作数不是浮点数，就只返回商，和整除的效果一样; py3中, 除法是精确除法，整除用// <br>
    eg: py2: 5 / 2 = 2; 5.0 / 2= 2.5;   py3: 5 / 2= 2.5; 5 // 2 = 2
* 如说抽某张ssr的概率定为0.01%，怎样去测试，让我现场手写代码<br>
  反向思考：抽n张牌，至少抽到一张的概率为 p = 1-(1-0.0001)^n , 所以抽的张数的期望为：n * p，用代码模拟抽n次，只要抽到的张数在期望附近，即可
  
* 微信抢红包设计测试用例
  * 一对一发红包
    * 界面
    * 输入框、按钮有效性测试：输入框接收的字符类型、数值类型、数值范围、长度等校验，按钮点击与不可点击测试
    * 跳转到支付时：根据红包金额  匹配零钱支付和银行卡支付；若无卡或者想添加新卡时，添加银行卡信息
    * 支付两种场景：支付成功 和 失败；在相应的支付账户里金额减少
    * 对方点击红包 和 自己点击红包 界面展示的信息不一样
    * 对方抢红包，对方余额增加；对方在一定的时间范围内没有抢红包，金额退回发红包人的原支付方式
    * 红包被抢了之后，再次点击红包，界面提示
    * 网络测试：弱网或者断网测试
    * 性能测试：如负载测试、压力测试、极限测试、容量测试等
  * 群发红包
    * 同上，再增加以下几条
    * 红包类型的选择（普通红包还是随机红包）
    * 群里的某个人点击到抢红包的页面，抢和不抢的情况
    * 同一个人多次点击抢红包
    * 红包被抢完情况 和 红包未抢完、超时退换
    * 多人同时抢红包，红包金额减少数目是正确的，不会有溢出或脏读现象
   
* 手写快排，平均时间复杂度，最坏时间复杂度，最坏的情况是什么样的
  ```python
  def QuickSort(arrs, left, right):
    if left > right:
        return arrs
    low, high = left, right
    key = arrs[left]
    while low < high:
        while low < high and arrs[high] >= key:
            high -= 1
        arrs[low] = arrs[high]
        while low < high and arrs[low] <= key:
            low += 1
        arrs[high] = arrs[low]
    arrs[low] = key
    QuickSort(arrs, left, low - 1)
    QuickSort(arrs, low + 1, right)
    return arrs
  ```
  最好的情况，每次都把数组平分;最坏的情况，退化为冒泡排序，每次把长度为n的数组分为长度为n-1和1 的两个数组，时间复杂度O(n^2);平均时间复杂O(nlogn)
  
* 数组和链表的区别
  * 存储、增删改查的效率来说
* 冒泡算法复杂度
  * O(n^2)
  
* 说一说你知道的什么软件是用tcp协议？什么软件是用UDP协议？tcp和udp区别？
 * TCP：浏览器用的HTTP协议；文件传输FTP协议；收发邮件中用的POP、SMTP；Telnet、SSH远程登录
 * UDP：语音、视频通话；实时游戏
 * [区别](https://github.com/MissAquarius/ForJobHunting/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B.md)
 
* 三次握手，两次会怎样？ 四次挥手，3次会怎样？
  * 三次握手而不是两次，可以防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。 如：客户端发出第一个连接请求报文，在网络中某个节点长时间滞留了，而客户端以为该报文丢失了，所以发出第二个连接请求报文，发送数据，直到连接关闭。此时，刚第一个延误的请求连接报文达到了服务端，服务端发回了连接确认的包，如果是两次握手，此时连接就建立了。但实际上客户端并没有发出建立连接的请求，因为不会理睬服务端的连接，这样服务端一直在等待状态，浪费资源。像这种情况，如果是三次握手，即客户端需要向服务端的确认发出确认，那么由于服务端一直收不到确认，就知道客户端没有要求建立连接。
  * 四次挥手而不是三次：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。如果是三次握手的话，服务器等待超时时自己关闭连接，会浪费资源。

*  一次只能跳一个台阶或者两个台阶，100级台阶有几种调法？<br>
  DP：F(n) = F(n-1) + F(n-2) n >=2; n=0时，F(n) = 1; n =1 时， F(n) = 1
  
* 线程、进程区别；如何保证线程安全？<br>
  [见这里](https://github.com/MissAquarius/ForJobHunting/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/20190406-vivo.md)
  
* 用代码实现了一个你上述说的锁？（不是底层，怎么用volitale和Synchronized就行，当时就捡了个简单的写）<br>
  不会
* 死锁 <br>
  四个条件：互斥(一个资源只能被一个线程拥有)、不剥夺（一个线程在释放资源之前，其他的线程无法剥夺使用）、占有并等待（一个线程对请求的资源发生阻塞时，对已经获得的资源不释放）、循环等待（发生死锁时，线程进入死循环，永久阻塞）
  
* 数组中找和为某一值的两个数
  * 两层循环
  * 先将整型数组排序，排序之后定义两个指针left和right。left指向已排序数组中的第一个元素，right指向已排序数组中的最后一个元素，将      arr[left]+arr[right]与 给定的元素比较，若前者大，right--；若前者小，left++；若相等，则找到了一对整数之和为指定值的元素。
  
* 树的遍历算法有哪些<br>
  层次遍历、前中后序遍历、深度优先遍历
  
* TCI/IP三次握手
* 数据库drop和delete的区别
  * 从删除内容上区分： delete只删除数据不删除表的结构(定义)；drop语句将删除表的结构、被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态.
　* 从语句类型上来区分：delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚；操作不触发trigger.
　* 从对表空间的影响来区分：delete语句不影响表所占用的空间；drop语句将表所占用的空间全部释放
　
* 索引的作用，何时无效 <br>
  作用： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性;可以大大加快 数据的检索速度<br>
  无效：索引列存在NULL值情况；NOT情况；LIKE通配符，前匹配；要对索引列使用函数<br>
* 面向对象的特性，怎么解释<br>
  封装:把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏; 继承:一个类有'子类'，子类(派生类)对比父类(基类/超类)实现更加具体化; 多态:由继承产生的相关的不同的类,其对象对于同一方法做出不同的效应<br>
 
* JAVA线程池的了解情况
* function不想被重写，怎么办<br>
  没懂题目意思，用装饰器吗？
  
* 复盘某游戏上线新英雄所需要进行的测试，主要有哪些方面的测试
  角色的技能、与其他角色的兼容性、<br>
  
* 2个玻璃珠100层问题:有一栋100层高的大楼，给你两个完全相同的玻璃球。假设从某一层开始，丢下玻璃球会摔碎。
  那么怎么利用手中的两个球，用什么最优策略知道这个临界的层是第几层？？？<br>
  设在X层，x + (x-1) + (x-2) + ... + 1 = 100, 解得x = 14
  
* 有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球 <br>
  解法：将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。
  
* http method post和get的区别 哪个效率高 哪个安全 <br>
  之前总结有；post安全，get效率高
  
* hashmap和hashtable区别

* 在线编程（二分查找）
  
* 数组找出重复数字（一个和多个的情况） <br>
  计数、排序后查找
  
* 淘宝登陆如何测试
  * 界面测试
  * 用户类型区分：新用户登录/老用户登录、不同的登录入口
  * 输入框测试（是否支持复制粘贴、大小写提示、密码展示）、按钮测试
  * 正确的用户名、密码与错误的交叉测试
  * 重复登录
  * 记住密码与忘记密码
  * 验证码
  * 性能测试：多用户、响应速度、
  * 登录后点击【回退】，应不能回退
  * 安全测试：登录成功后的Cookie、SQL注入攻击、用户名和密码是否是加密的方式发给服务器、输入框输入禁止脚本、错误登录次数的显示、多用户在同一机器上登录和一个用户在多个机器上登录、
  * 可用性测试：常用的快捷键如Tab、回车正常使用
  * 兼容性测试：不同的平台、浏览器、设备上正常使用
  * 不同语言环境下，页面的显示是否正确
  
* 单链表有没有环找环节点 <br>
  快慢指针；环
  
* 数组的2-sum，3-sum <br>
  [3-sum](https://github.com/MissAquarius/LeetCode/blob/master/015%203Sum.md) <br>
  [2-sum](https://github.com/MissAquarius/LeetCode/blob/master/001%20%20Two%20Sum.md) 
* 海盗分金币
  有5个海盗，获得了100枚金币，于是他们要商量一个方法来分配金币。商议方式如下：
  1. 由5个海盗轮流提出分配方案。
  2. 如果超过半数海盗（包括提出者）同意该方案，则按照该方案分配。
  3. 如果同意该方案的人数（包括提出者）小于等于半数，则提出者要被扔到海里喂鱼，剩下的海盗继续商议分配。
  4. 海盗们都是绝对理性的，以自己尽可能多获得金币为目的。但是在收益相等的情况下，会倾向把提出者扔到海里。
  问：第一个海盗应该提出怎样的分配方案，才能保证自己既不被扔到海里，又能使自己利益最大化？
  [解法](https://blog.csdn.net/csdnsevenn/article/details/86522861)，主要用递归的思想，终止条件是只剩下4号和5号，那么无论4号干啥，5号都会反对，所以可以推出3号的最优方案，以此推到1号，最终答案是：97, 0, 1, 0, 2 或者 97, 0, 1, 2, 0.
  
* 烧绳子得到15分钟
  * 同下，需要两根绳子
  * 变种：烧一根不均匀的绳,从头烧到尾总共需要1小时.现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢?<br>
    解法：需要三根绳子；#1 和 #2 同时点燃，#1只点燃一头，#2两头都点着；等到#2燃烧尽，过了30min； 此时点燃 #1的另一头，#1燃烧尽，过了15min；此时点燃#3，两头都点，#3燃烧尽，过去30min. 攻击：30 + 15 + 30 = 1h 15 min
  
* 5个扑克牌是否是顺子，大小王当成任意的（在线编程）
  ```python
  # -*- coding:utf-8 -*-
  class Solution:
    def IsContinuous(self, numbers):
        # write code here
        if len(numbers) != 5:
            return False
        mmax, mmin = -1, 14
        for i in range(len(numbers)):
            if numbers[i] == 0:
                continue
            if numbers[i] in numbers[:i] or numbers[i] in numbers[i+1:]:
                return False
            mmax = max(mmax, numbers[i])
            mmin = min(mmin, numbers[i])
        if mmax - mmin > 4:
            return False
        return True
  ```
  思路：逐个遍历，遇到0就continue; 同时判断是否存在对子（即有重复的）; 记录最值，如果最值超过4，说明不是顺子,复杂度高，应该是O(n^2)
  
* static作用
* gc介绍

* 如何设计游戏中的朋友圈，尽量从技术角度说下，而不仅仅是说有哪些功能
  不会
  
* 让你觉得好的游戏机制有那些
  大部分玩家的胜率在一个合理的数字范围，既不会让玩家一直赢，也不会一直输，进而在游戏中流连忘返；
  
* 问你个算法题吧，如果有一个棋牌游戏，一局游戏平均会有5~7轮出牌操作，这些操作包括对子、三带空、三带一、顺子等，设计一个算法求玩家最少能几次出完牌？”
* 
    
