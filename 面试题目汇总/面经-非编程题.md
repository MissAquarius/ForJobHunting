## 网易游戏-测试
* py2和py3的的区别：
  * 编码：python2默认编码方式ASCII码（不能识别中文，要在文件头部加上  #-*- encoding：utf-8 -*-  指定编码方式）；python3默认编码方式unicode（可识别中文）
  * print函数，py2中加不加括号都可以，py3中必须加括号
  * input：py2中input()函数得到int类型，而raw_inpt()得到str类型; py3中input()得到str类型
  * range: py2中range()/xrange(); py3中range()
  * 整除：py2的除法，操作数不是浮点数，就只返回商，和整除的效果一样; py3中, 除法是精确除法，整除用// <br>
    eg: py2: 5 / 2 = 2; 5.0 / 2= 2.5;   py3: 5 / 2= 2.5; 5 // 2 = 2
* 如说抽某张ssr的概率定为0.01%，怎样去测试，让我现场手写代码<br>
  反向思考：抽n张牌，至少抽到一张的概率为 p = 1-(1-0.0001)^n , 所以抽的张数的期望为：n * p，用代码模拟抽n次，只要抽到的张数在期望附近，即可
  
* 微信抢红包设计测试用例
  * 一对一发红包
    * 界面
    * 输入框、按钮有效性测试：输入框接收的字符类型、数值类型、数值范围、长度等校验，按钮点击与不可点击测试
    * 跳转到支付时：根据红包金额  匹配零钱支付和银行卡支付；若无卡或者想添加新卡时，添加银行卡信息
    * 支付两种场景：支付成功 和 失败；在相应的支付账户里金额减少
    * 对方点击红包 和 自己点击红包 界面展示的信息不一样
    * 对方抢红包，对方余额增加；对方在一定的时间范围内没有抢红包，金额退回发红包人的原支付方式
    * 红包被抢了之后，再次点击红包，界面提示
    * 网络测试：弱网或者断网测试
    * 性能测试：如负载测试、压力测试、极限测试、容量测试等
  * 群发红包
    * 同上，再增加以下几条
    * 红包类型的选择（普通红包还是随机红包）
    * 群里的某个人点击到抢红包的页面，抢和不抢的情况
    * 同一个人多次点击抢红包
    * 红包被抢完情况 和 红包未抢完、超时退换
    * 多人同时抢红包，红包金额减少数目是正确的，不会有溢出或脏读现象
   
* 手写快排，平均时间复杂度，最坏时间复杂度，最坏的情况是什么样的
  ```python
  def QuickSort(arrs, left, right):
    if left > right:
        return arrs
    low, high = left, right
    key = arrs[left]
    while low < high:
        while low < high and arrs[high] >= key:
            high -= 1
        arrs[low] = arrs[high]
        while low < high and arrs[low] <= key:
            low += 1
        arrs[high] = arrs[low]
    arrs[low] = key
    QuickSort(arrs, left, low - 1)
    QuickSort(arrs, low + 1, right)
    return arrs
  ```
  最好的情况，每次都把数组平分;最坏的情况，退化为冒泡排序，每次把长度为n的数组分为长度为n-1和1 的两个数组，时间复杂度O(n^2);平均时间复杂O(nlogn)
  
* 数组和链表的区别
  * 存储、增删改查的效率来说
* 冒泡算法复杂度
  * O(n^2)
  
* 说一说你知道的什么软件是用tcp协议？什么软件是用UDP协议？tcp和udp区别？
 * TCP：浏览器用的HTTP协议；文件传输FTP协议；收发邮件中用的POP、SMTP；Telnet、SSH远程登录
 * UDP：语音、视频通话；实时游戏
 * [区别](https://github.com/MissAquarius/ForJobHunting/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B.md)
 
* 三次握手，两次会怎样？ 四次挥手，3次会怎样？
  * 三次握手而不是两次，可以防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。 如：客户端发出第一个连接请求报文，在网络中某个节点长时间滞留了，而客户端以为该报文丢失了，所以发出第二个连接请求报文，发送数据，直到连接关闭。此时，刚第一个延误的请求连接报文达到了服务端，服务端发回了连接确认的包，如果是两次握手，此时连接就建立了。但实际上客户端并没有发出建立连接的请求，因为不会理睬服务端的连接，这样服务端一直在等待状态，浪费资源。像这种情况，如果是三次握手，即客户端需要向服务端的确认发出确认，那么由于服务端一直收不到确认，就知道客户端没有要求建立连接。
  * 四次挥手而不是三次：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。如果是三次握手的话，服务器等待超时时自己关闭连接，会浪费资源。

*  一次只能跳一个台阶或者两个台阶，100级台阶有几种调法？<br>
  DP：F(n) = F(n-1) + F(n-2) n >=2; n=0时，F(n) = 1; n =1 时， F(n) = 1
  
* 线程、进程区别；如何保证线程安全？<br>
  [见这里](https://github.com/MissAquarius/ForJobHunting/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/20190406-vivo.md)
  
* 用代码实现了一个你上述说的锁？（不是底层，怎么用volitale和Synchronized就行，当时就捡了个简单的写）<br>
  不会
* 死锁 <br>
  四个条件：互斥(一个资源只能被一个线程拥有)、不剥夺（一个线程在释放资源之前，其他的线程无法剥夺使用）、占有并等待（一个线程对请求的资源发生阻塞时，对已经获得的资源不释放）、循环等待（发生死锁时，线程进入死循环，永久阻塞）
  
* 数组中找和为某一值的两个数
  * 两层循环
  * 先将整型数组排序，排序之后定义两个指针left和right。left指向已排序数组中的第一个元素，right指向已排序数组中的最后一个元素，将      arr[left]+arr[right]与 给定的元素比较，若前者大，right--；若前者小，left++；若相等，则找到了一对整数之和为指定值的元素。
  
* 树的遍历算法有哪些<br>
  层次遍历、前中后序遍历、深度优先遍历
  
* TCI/IP三次握手
* 数据库drop和delete的区别
  * 从删除内容上区分： delete只删除数据不删除表的结构(定义)；drop语句将删除表的结构、被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态.
　* 从语句类型上来区分：delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚；操作不触发trigger.
　* 从对表空间的影响来区分：delete语句不影响表所占用的空间；drop语句将表所占用的空间全部释放
　
* 索引的作用，何时无效 <br>
  作用： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性;可以大大加快 数据的检索速度<br>
  无效：索引列存在NULL值情况；NOT情况；LIKE通配符，前匹配；要对索引列使用函数<br>
* 面向对象的特性，怎么解释<br>
  封装:把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏; 继承:一个类有'子类'，子类(派生类)对比父类(基类/超类)实现更加具体化; 多态:由继承产生的相关的不同的类,其对象对于同一方法做出不同的效应<br>
 
* JAVA线程池的了解情况
* function不想被重写，怎么办<br>
  没懂题目意思，用装饰器吗？
  
* 复盘某游戏上线新英雄所需要进行的测试，主要有哪些方面的测试
  角色的技能、与其他角色的兼容性、<br>
  
* http method post和get的区别 哪个效率高 哪个安全 <br>
  之前总结有；post安全，get效率高
  
* hashmap和hashtable区别

* 在线编程（二分查找）
  
* 数组找出重复数字（一个和多个的情况） <br>
  计数、排序后查找

* 淘宝登陆如何测试
  * 界面测试
  * 用户类型区分：新用户登录/老用户登录、不同的登录入口
  * 输入框测试（是否支持复制粘贴、大小写提示、密码展示）、按钮测试
  * 正确的用户名、密码与错误的交叉测试
  * 重复登录
  * 记住密码与忘记密码
  * 验证码
  * 性能测试：多用户、响应速度、
  * 登录后点击【回退】，应不能回退
  * 安全测试：登录成功后的Cookie、SQL注入攻击、用户名和密码是否是加密的方式发给服务器、输入框输入禁止脚本、错误登录次数的显示、多用户在同一机器上登录和一个用户在多个机器上登录、
  * 可用性测试：常用的快捷键如Tab、回车正常使用
  * 兼容性测试：不同的平台、浏览器、设备上正常使用
  * 不同语言环境下，页面的显示是否正确
  
* 单链表有没有环找环节点 <br>
  快慢指针；环
  
* 数组的2-sum，3-sum <br>
  [3-sum](https://github.com/MissAquarius/LeetCode/blob/master/015%203Sum.md) <br>
  [2-sum](https://github.com/MissAquarius/LeetCode/blob/master/001%20%20Two%20Sum.md) 
* static作用
* gc介绍
* 如何设计游戏中的朋友圈，尽量从技术角度说下，而不仅仅是说有哪些功能
  不会
  
* 让你觉得好的游戏机制有那些
  大部分玩家的胜率在一个合理的数字范围，既不会让玩家一直赢，也不会一直输，进而在游戏中流连忘返；
  
* 问你个算法题吧，如果有一个棋牌游戏，一局游戏平均会有5~7轮出牌操作，这些操作包括对子、三带空、三带一、顺子等，设计一个算法求玩家最少能几次出完牌？”

## 作业帮测开
* 数组和链表区别（从增删改查上说）？以及用途
  存储方式、增删改查的效率、用途就从效率来说
* 测试工具
  * LoadRunner：模拟多用户并发操作，负载测试
  * Selenium：Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。它的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建衰退测试检验软件功能和用户需求。支持自动录制动作和自动生成。
  * Jmeter：性能测试
* 测作业帮拍照搜题功能
  * 拍照搜题的过程：主页->点击屏幕上方的【拍照搜题】->对准所要搜索的题目，点击【照相机】图标->框选题目，点击【对号】图标等待搜索结果
  * 界面测试：所有界面风格符合UI设计稿
  * 功能测试：假设用户已经安装好了作业帮，且已经登录；按照步骤，测试（注意相机那里提一下横竖屏切换以及app使用相机的权限）
  * 性能测试：
  * 网络测试：在各种网络环境中，比如移动网、无线网情况下；弱网；断网测试
  * 安全测试：上传的图片文件中注入病毒
* 黑盒、白盒测试的概念
* 单元测试概念
  单元测试是对软件中的最小可验证单元（明确的小功能点）进行检查和验证。可以是一个类，或者一个函数。  
* 软件生命周期
  计划、分析、设计、实施、运行、维护
* 数据库增加一列：
  ALTER TABLE Student ADD Name char(50)
* 堆和栈的区别？当内存溢出，分别是什么情况？
  * 此处的堆和栈是指内存中的“堆区”和“栈区”，除此之外，内存模型还有：代码区、常量区、静态区
  * 栈区：存放函数的参数、局部变量等，由编译器自动分配和释放，通常在函数执行完就释放了；栈空间比较小，一般存储基本数据类型、对象的地址等
  * 堆区：是用过new等操作动态分配的内存块，编译器不负责它们的释放，需要用程序去释放；堆空间比较大，一般存储对象本身
  * 栈溢出：一般是递归深度过深，导致了超过了栈的深度
  * 堆溢出：堆中主要存储的是对象，如果不断的new对象而不释放的话，会导致堆中的空间溢出
* 一维数组和二维数组的区别？
  可以从指针上答
* 用过哪些装饰器？
  * 对函数的一种包装，能使函数的功能得到扩充，而同时不用修改函数本身的代码；它能够增加函数执行前、执行后的行为，而不需对调用函数的代码做任何改变
* 功能测试和自动化测试的区别？
  这俩都不是对立面，按照定义说就行
* 你了解的测试理论都有什么？说一下白盒测试？
* 说一下白盒测试和功能测试怎么一起实现？
  * 白盒测试方法：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖
  * 语句覆盖每条语句至少执行一次。
  * 判定覆盖每个判定的每个分支至少执行一次。
  * 条件覆盖每个判定的每个条件应取到各种可能的值。
  * 判定/条件覆盖同时满足判定覆盖条件覆盖。
  * 条件组合覆盖每个判定中各条件的每一种组合至少出现一次。
  * 其实这些方法执行的过程，就把功能测试里面的功能点执行了一遍
* 你对测试开发的理解是什么？
  * 除了功能测试之外，更注重自动化测试、测试工具的开发
* 逻辑算法题：<br>
   丢了一个东西，总共有ABCD四个人，其中有一个人说了假话，3个人说了真话：<br>
   A：不是我偷的；    B：C偷的；    C：D偷的；    D：C撒谎了； 
   请问到底谁撒谎了，现在用程序来实现你说的过程？<br>
   ```python
  if __name__ == '__main__':
      murderers = ['A', 'B', 'C', 'D']
      for murderer in murderers:
          if (murderer != 'A') + (murderer == 'C') + (murderer == 'D') + (murderer != 'D') == 3:
              print(murderer)
   ```
 * linux查看与mysql相关的进程
   ps -ef|grep mysql 
 * TCP为什么是三次握手
   保证双方都可以接受并且传递消息
 * TCP实现可靠传输的方法
   * 确认号：ACK
   * 超时重传
   * TCP的连接管理：三次握手与四次挥手
   * 滑动窗口
   * 流量控制：设置滑动窗口的大小，控制流量
   * 拥塞控制
 * TCP的拥塞控制
   * 慢开始：当发送端开始发送数据时，如果立即将大量数据字节注入到网络，那么就有可能因为不清楚当前网络的负荷情况而引起网络阻塞。所以，最好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。
   * 拥塞避免：只要判断网络出现拥塞，就要把慢启动开始门限（ssthresh）设置为发送窗口的一半（>=2），cwnd设置为1，然后再使用慢启动算法，这样做的目的能迅速的减少网络当中的数据传输，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。
   * 快重传：当接收方收到一个失序的报文段后立刻发出重复确认
   * 快恢复：当发送方连续收到三个重复确认时，执行“乘法减小”算法，慢启动门限减半，为了预防网络发生阻塞
 * socket编程实现tcp的过程
 * https的原理
 * 套接字的好处
 * AVL树 特性
   * AVL树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
   * 在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树
 * 完全二叉树 有n个结点，求深度
   * 「log2n」+1
 * 链表的特点
   可以从增删改查来说
 * 快排
 * 二叉树的层序遍历--OK
 * 用代码模拟洗牌过程，及如何测试
   * 稍后补充：52张牌，4中花色，每种花色从1-12，用k%4 表示数字；K//4 表示花色
   * random模块
 * 写linux常用命令
 * http协议有几种请求类型
 * 栈和队列的区别及其使用场景
 * 项目中用到的测试方法
 * 索引的优缺点
   * 优点： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；可以加快数据的检索速度，这也是创建索引的最主要的原因；可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义；在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
   * 缺点：建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加；索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大；当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
   
## Shopee测开
 * 从输入URL后发生了什么
   * 
 * char和vchar区别
   * char的长度是不可变的，而varchar的长度是可变的；
   * 定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的，
   * char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。
   * char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节。
 * 会性能测试吗？性能测试需要哪些工具？用过吗
 * 写一下QQ登录的测试用例
   * 界面
   * 快捷键
   * 输入框（输入空/非空、是否支持复制粘贴移动、密文的显示）
   * 验证码
   * 网络
   * 安全：登录次数
 * adb查看手机里的进程
     adb shell 进入手机linux系统后，执行ps就能显示手机里所有正在运行的进程
 * adb安装应用程序（因为实习接触android手机所以提了下会adb，一般不会考adb的）
 * 像我们这种视频聊天用了什么网络协议？
 * 网络的基本分层有哪些？
   * OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
   * 五层模型：物理层、数据链路层、网络层、传输层、应用层
 * 客户端发一个请求到服务端拿到一个结果，每一层都做了什么？
 * 你知道selenium工具做什么的吗
 * 对微信app的聊天界面进行测试（包括ios及安卓端），仅测试文本框（用于键盘输入）以及聊天记录的页面，仅测试文字发送，仅测试一对一聊天，请从业务、技术、经验等方面，列出你的测试点。
 * 从聊天历史记录页面有什么可以扩展的测试点。
 * 如果安卓系统经常出现黑屏，可能是什么原因。
   * 外部原因：摔过、潮湿环境中、电池使用不当
   * 内部软件原因：内存占用过度、软件冲突
 * 安卓界面的渲染你了解吗？比如什么时候会丢帧之类的。
 * 在Linux系统下怎么查看进程状态？

## 京东测开
* 启动命令 nohup & nohup重定向输出日志 如何重定向的 重定向哪些日志内容
* 数据库 表 有个字段 name字段 name=liuguoge 唯一标识id=3 修改name=guogeliu
  update table set name = 'guogeliu' where id = 3
* 写链表翻转（说思路，代码中每一行的作用）
* 并发调用有什么问题吗（局部变量和全局变量）
* Scp和wget区别
* 重载与重写区别
* C++多态

## 智力题
* 2个玻璃珠100层问题:有一栋100层高的大楼，给你两个完全相同的玻璃球。假设从某一层开始，丢下玻璃球会摔碎。
  那么怎么利用手中的两个球，用什么最优策略知道这个临界的层是第几层？？？<br>
  设在X层，x + (x-1) + (x-2) + ... + 1 = 100, 解得x = 14
  
* 有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球 <br>
  解法：将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。
  
* 海盗分金币
  有5个海盗，获得了100枚金币，于是他们要商量一个方法来分配金币。商议方式如下：
  1. 由5个海盗轮流提出分配方案。
  2. 如果超过半数海盗（包括提出者）同意该方案，则按照该方案分配。
  3. 如果同意该方案的人数（包括提出者）小于等于半数，则提出者要被扔到海里喂鱼，剩下的海盗继续商议分配。
  4. 海盗们都是绝对理性的，以自己尽可能多获得金币为目的。但是在收益相等的情况下，会倾向把提出者扔到海里。
  问：第一个海盗应该提出怎样的分配方案，才能保证自己既不被扔到海里，又能使自己利益最大化？
  [解法](https://blog.csdn.net/csdnsevenn/article/details/86522861)，主要用递归的思想，终止条件是只剩下4号和5号，那么无论4号干啥，5号都会反对，所以可以推出3号的最优方案，以此推到1号，最终答案是：97, 0, 1, 0, 2 或者 97, 0, 1, 2, 0.
  
* 烧绳子得到15分钟
  * 同下，需要两根绳子
  * 变种：烧一根不均匀的绳,从头烧到尾总共需要1小时.现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢?<br>
    解法：需要三根绳子；#1 和 #2 同时点燃，#1只点燃一头，#2两头都点着；等到#2燃烧尽，过了30min； 此时点燃 #1的另一头，#1燃烧尽，过了15min；此时点燃#3，两头都点，#3燃烧尽，过去30min. 攻击：30 + 15 + 30 = 1h 15 min

* 1，10，3，5，(  ) 给出几种解法，不局限于数学
  * 将10当成二进制，就成了斐波那契数列
  * 用阿拉伯数字表示，一、十、三、五，画数分别是：1、2/3/4，接下去找个5画的
  
* 有一个随机数发生器，以概率P产生0，概率(1-P)产生1，请问能否利用这个随机数发生器，构造出新的发生器，以1/2的概率产生0和1 <br>
  解法：目的是找到两个独立事件，使其发生的概率分别是0.5<br>
  考虑：用随机数发生器产生：00,01,10,11 则概率分别是：p^2, p(1-p), (1-p)p, (1-p)^2,这四个概率中，中间两个概率相同，因此保留这两个，将01映射成0,10映射成1，则等概率0/1随机数生成器可以得到。
  
*
  
