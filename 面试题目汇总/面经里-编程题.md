## 字节跳动（后端）
* 验证密码，长度要求在[6,20]之间，大写字母 小写字母 数字 其他至少要三种，不能有长度超过2的重复子串
```python
def CheckLegth(pwd):
    size = len(pwd)
    if size < 6 or size > 20:
        return False
    return True
def CheckTypes(pwd):
    types = [0, 0, 0, 0]
    for i in range(len(pwd)):
        if pwd[i].isdigit():
            types[0] = 1
        elif pwd[i].isupper():
            types[1] = 1
        elif pwd[i].islower():
            types[2] = 1
        else:
            types[3] = 1
    if sum(types) < 3:
        return False
    return True
def ChcekSubString(pwd):
    size = len(pwd)
    for i in range(size-2):
        for j in range(i + 3, size):
            if pwd[i:j] in pwd[j:]:
                return False
    return True
if __name__ == '__main__':
    pwd = input()
    if CheckLegth(pwd) and CheckTypes(pwd) and ChcekSubString(pwd):
        print('OK')
    else:
        print('NG')
```
* [55. Jump Game](https://leetcode.com/problems/jump-game/)
```python
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        size = len(nums)
        isarrive = [False for i in range(size)]
        isarrive[0] = True
        for i in range(1, size):
            for j in range(i):
                if isarrive[j] == True and nums[j] >= i-j:
                    isarrive[i] = True
        return isarrive[size-1]
```
超时解法

```python
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        size = len(nums)
        reach = 0
        for i in range(size):
            if i > reach: # reach小于当前位置i，表示到不了当前位置
                return False
            reach = max(reach, i + nums[i]) 
            if reach >= size - 1:
                return True
        return False
```
贪心算法：i表示当前坐标，reach表示可以到达的最远地方；只要reach大于最后一个位置的时候就可以，不是要求正好相等

*  捡金币，n * n的格，-1表示障碍，该格不能走，0表示可以通过，1表示有一个金币，grid的值只有这三种，从左上到右下，只能向右或向下，到最后一格，
然后再从右下到左上，只能向左或向上，求能够获得的最大金币数。第一次走过的格子，捡了金币后应该置为0，该格还可以继续走，(0，0)和(-1，-1)这两格不会是-1。
```python
# -*- coding:utf-8 -*-

def PickGold(grid):
    size = len(grid)
    # dp[i][j]表示[i,j]格子可以获得的最大金币数
    dp = [[0 for _ in range(size)] for _ in range(size)]
    dp[0][0] = grid[0][0]
    grid[0][0] = 0

    # 第一行只能向右走
    for j in range(1, size):
        if grid[0][j] == -1: # 有一个格子为-1，后面的都不能走了，直接跳出循环
            break
        else:
            dp[0][j] = dp[0][j-1] + grid[0][j]
            grid[0][j-1] = 0  # 捡完后置0

    # 第一列只能向下走
    for i in range(1, size):
        if grid[i][0] == -1:
            break
        else:
            dp[i][0] = dp[i-1][0] + grid[i][0]
            grid[i-1][0] = 0

    for i in range(1, size):
        for j in range(1, size):
            if grid[i][j] == -1:
                continue
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]
                # 判断是由哪个格子过来的，将格子金币数置0
                if dp[i][j] == dp[i][j-1] and grid[i][j-1] != -1:
                    grid[i][j-1] = 0
                if dp[i][j] == dp[i-1][j] and grid[i-1][j] != -1:
                    grid[i][j] = 0

    return grid, dp[size-1][size-1]


if __name__ == '__main__':
    grid = [[1,2,3],[4,5,6],[7,8,9]]
    size = len(grid)
    # 左上到右下
    grid, total1 = PickGold(grid)

    # 翻转grid
    newgrid = [[0 for _ in range(size)] for _ in range(size)]
    for i in range(size):
        for j in range(size):
            newgrid[i][j] = grid[size-1-i][size-1-j]
    # 右下到左上
    grid, total2 = PickGold(newgrid)
    
    total = total1 + total2
    print(total)
```

## 小米
* 中文数字转阿拉伯数字，如“一百五十万九千零二十一”转为“1509021”
```python
# -*- coding:utf-8 -*-
# 中文数字转阿拉伯数字，如“一百五十万九千零二十一”转为“1509021”

def chinese2digit(s):
    res = 0
    r = 1  # 表示单位
    tmp = 0
    dict1 = {'零': 0, '一': 1, '二': 2, '三': 3, '四': 4, '五': 5,
             '六': 6, '七': 7, '八': 8, '九': 9, '十': 10, '百': 100,
             '千': 1000, '万': 10000, '亿': 100000000}
    for i in range(len(s)-1, -1, -1):
        num = dict1[s[i]]
        if i == 0 and num == 10:  # 处理 十一、十二等这种
            res += num
        else:
            if num < 10:
                if tmp:
                    res += num * tmp
                else:
                    res += num * r
            else:
                if num > r:
                    r = num
                    tmp = 0
                else:
                    tmp = r * num  # 遇到一百五十万这种，百是和万相乘，而不是和十万相乘
    return res


if __name__ == '__main__':
    print(chinese2digit('二百三十二'))
    print("-------------------------")
    print(chinese2digit('十二'))
    print("-------------------------")
    print(chinese2digit('一亿零八万零三百二十三'))
    print("-------------------------")
    print(chinese2digit('一百五十万九千零二十一'))

```
* [Leetcode174. Dungeon Game](https://leetcode.com/problems/dungeon-game/)
```python
class Solution(object):
    def calculateMinimumHP(self, dungeon):
        """
        :type dungeon: List[List[int]]
        :rtype: int
        """
        # dp[i][j]表示到达(i,j)前所需要的最小hp值
        rows = len(dungeon)
        cols = len(dungeon[0])
        dp = [[0 for _ in range(cols)] for _ in range(rows)]
        dp[-1][-1] = max(1, 1- dungeon[rows-1][cols-1])
        
        # 最后一行只能往右走
        for j in range(cols-2, -1, -1):
            dp[rows-1][j] = max(1, dp[rows-1][j+1] - dungeon[rows-1][j])

        # 最后一列只能往下走
        for i in range(rows-2, -1, -1):
            dp[i][cols-1] = max(1, dp[i+1][cols-1] - dungeon[i][cols-1])
        
        for i in range(rows-2, -1, -1):
            for j in range(cols-2, -1, -1):
                left = max(1, dp[i][j+1] - dungeon[i][j])
                top = max(1, dp[i+1][j] - dungeon[i][j])
                dp[i][j] = min(left, top)
                
        return dp[0][0]
```
* 跳台阶问题及其变种
 * [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
 ```python
 class Solution(object):         
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 0:
            return 0
        a = 0
        b = 1
        for i in range(1, n+1):
            res = a + b
            a = b
            b = res
        return res
 ```
 一次只能跳一步或者两步，问到第N个台阶，一共有几种跳法斐波拉契数列
 * 剑指offer上的扩展：一只青蛙一次可以跳上1级台阶，也可以跳上2 级，……，也可以跳上n级，此时该青蛙跳上一个n级的台阶总共有多少种跳法？
 ```python
 def climbstairs(n):
    steps = [1]
    for i in range(n+1):
        res = sum(steps) # res = 2 * steps[-1]
        steps.append(res)
    return res
 ```
 可以简化为：f(n) = f(n-1) + f(n-2) + ... + f(1) + f(0) 而f(n-1) = f(n-2) + ... + f(1) + f(0) <br>
 f(n) = 2 * f(n-1)
 
 * [55. Jump Game](https://leetcode.com/problems/jump-game/)系列
 
 ## 作业帮（测开）
* 约瑟夫环问题（剑指offer：孩子们的游戏）
```python
# -*- coding:utf-8 -*-
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        # 异常情况
        if n == 0 or m == 0:
            return -1
        
        last = 0
        for i in range(2, n+1):
            last = (last + m) % i
        return last
```
设n个人的时候，最后幸存者的位置坐标为p(n),那么n-1个人的时候，最后幸存者的位置坐标就为p(n-1)。要求最后幸存者的人的坐标，即为求p(n)的值<br>
利用数学归纳法，如果p(n)可以由n前面的数推过来即可。可以写出递推公式为：p(n) = (p(n-1) + k) % n  <br>
参考链接：https://www.jianshu.com/p/6ee5c7b21333

```python
# -*- coding:utf-8 -*-
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        if n < 1 or m < 1:
            return -1
        # arr数组记录下标
        arr = [i for i in range(n)]
        remove_index = 0
        while len(arr) > 1:
            remove_index += (m-1)
            if remove_index >= len(arr):
                remove_index %= len(arr)
            arr.pop(remove_index)
        return arr[0]

```
普通方法：用arr数组记录原来的下标。每次查找arr数组中要删除的元素的index<br>
list.pop(index); list.remove(value)根据索引和值删除list中元素

```python
# -*- coding:utf-8 -*-
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        
        if m == 0 or n == 0:
            return -1
        # 创建循环链表
        head = ListNode(0)
        temp1 = head
        for i in range(1, n):
            temp1.next = ListNode(i)
            temp1 = temp1.next
        temp1.next = head
        
        # 遍历
        while n > 1:
            temp2 = head
            # 先找到被删除节点的前驱，修改指针指向
            for j in range(1, m-1):
                temp2 = temp2.next
            temp2.next = temp2.next.next
            # 重新head指针指向新头
            head = temp2.next
            n -= 1
        return head.val

```
自己构建循环链表，然后遍历找到要删除的节点，修改指针指向，直到只剩下一个节点，输出
* 删除链表中多余结点
```python
# -*- coding:utf-8 -*-
class ListNode:
    def __init__(self, x):
        self.value = x
        self.next = None

def RemoveDuplicateNode(head):
    if not head:
        return head
    dummy = ListNode(-1)
    dummy.next = head
    pre = dummy
    cur = head
    s = set()
    while cur:
        if cur.val in s:
            pre.next = cur.next
        else:
            s.add(cur.val)
            per = cur
        cur = cur.next
```

* 如果两个字符串，数字中每个字符的个数都相等，如"123""321"，定义为相等。需要考虑有重复字符情况
  ```python
  def helper(s):
    if not s:
        return {}

    d = {}
    for char in s:
        if char in list(d.keys()):
            d[char] += 1
        else:
            d[char] = 1
    return d
   if __name__ == '__main__':
        s1 = '12311'
        s2 = '11123'
        d1 = helper(s1)
        d2 = helper(s2)
        print(d1 == d2)
  ```
  判断字典是否相等，可以直接用等号判断，稍后补充一个自己实现的判断字典相等的方法。
  
* 翻转单词顺序列(“student. a am I”变成“I am a student.”)并设计测试用例
```python
class Solution:
    def ReverseSentence(self, s):
        # write code here
        words = s.split(' ')
        res = ''
        for i in range(len(words)-1,0, -1):
            res = res[:] + words[i] + ' '
        res = res[:] + words[0]
        return res
```
通过list分割

## Shopee测开
* 数手指游戏 ：以‘s’型，数单手五个手指，拇指数1，食指数2，中指数3，无名指数4，小指数5，再回头无名指6，中指7.。。以此类推，疏导10000在哪个手指上？
  ```python
  def helper(n):
    count = 0
    while count < n:
        for i in range(1, 6):
            count += 1
            if count == n:
                return i
        for j in range(4, 1, -1):
            count += 1
            if count == n:
                return j
  ``` 
  模拟数数字的过程，第一个循环是正着数，第二个是倒着数，1-5分别表示五个手指
  
* 实现功能：用户名（长度5-31个字符，限定为字母、数字、下划线），密码（长度8-16，必须包括字母大小写、数字、特殊符号）用户名、密码均不能为空、空字符和全特殊字符

* 一串字符 找出长度>3的回文串位置

* 判断两个数组中是否存在相同的数字 – 两个已经排序好的数组，写代码判断这两个数组中是否存在相同的数字？要求时间复杂度越低越好。
```python
def helper(arr1, arr2):
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            return True
        if arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return False
```
注意：如果改变if的顺序，即在i+1后还使用了i，那条件里面要增加判断，防止i越界

* 存在两个数据库表A（a1，a2，a3）和B（b1，b2，b3），写出A表中a3字段和B表中b1字段相等，且按照A表a1字段递减排序的记录（A.a1，A.a2,A.a3，B.b2,B.b3）输出第10-20条记录
```sql
## MySQL
select A.*, B.b2, B.b3
from A, B
where A.a3 = B.b1
order by A.a1 desc
limit 9, 11

## SQL Server
不会
```
mysql:limit用法 <br>
limit a, b == limit b offset a 跳过前a条数据，读取之后的b条数据 <br>
limit a 读取前a条数据 <br>
SQL Server中没有limit，可以用top模拟，如：select top 10 form table where id not in (select top 20 form table order by id desc)

* 高频其他问题：
  * 数组和链表区别（从增删改查上说）？以及用途
    存储方式、增删改查的效率、用途就从效率来说
  * 测试工具
    * LoadRunner：模拟多用户并发操作，负载测试
    * Selenium：Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。它的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建衰退测试检验软件功能和用户需求。支持自动录制动作和自动生成。
    * Jmeter：性能测试
  * 测作业帮拍照搜题功能
    * 拍照搜题的过程：主页->点击屏幕上方的【拍照搜题】->对准所要搜索的题目，点击【照相机】图标->框选题目，点击【对号】图标等待搜索结果
    * 界面测试：所有界面风格符合UI设计稿
    * 功能测试：假设用户已经安装好了作业帮，且已经登录；按照步骤，测试（注意相机那里提一下横竖屏切换以及app使用相机的权限）
    * 性能测试：
    * 网络测试：在各种网络环境中，比如移动网、无线网情况下；弱网；断网测试
    * 安全测试：上传的图片文件中注入病毒
  * 黑盒、白盒测试的概念
  * 单元测试概念
    单元测试是对软件中的最小可验证单元（明确的小功能点）进行检查和验证。可以是一个类，或者一个函数。  
  * 软件生命周期
    计划、分析、设计、实施、运行、维护
  * 数据库增加一列：
    ALTER TABLE Student ADD Name char(50)
  * 堆和栈的区别？当内存溢出，分别是什么情况？
    * 此处的堆和栈是指内存中的“堆区”和“栈区”，除此之外，内存模型还有：代码区、常量区、静态区
    * 栈区：存放函数的参数、局部变量等，由编译器自动分配和释放，通常在函数执行完就释放了；栈空间比较小，一般存储基本数据类型、对象的地址等
    * 堆区：是用过new等操作动态分配的内存块，编译器不负责它们的释放，需要用程序去释放；堆空间比较大，一般存储对象本身
    * 栈溢出：一般是递归深度过深，导致了超过了栈的深度
    * 堆溢出：堆中主要存储的是对象，如果不断的new对象而不释放的话，会导致堆中的空间溢出
  * 一维数组和二维数组的区别？
    可以从指针上答
  * 用过哪些装饰器？
    * 对函数的一种包装，能使函数的功能得到扩充，而同时不用修改函数本身的代码；它能够增加函数执行前、执行后的行为，而不需对调用函数的代码做任何改变
  * 功能测试和自动化测试的区别？
    这俩都不是对立面，按照定义说就行
  * 你了解的测试理论都有什么？说一下白盒测试？
  * 说一下白盒测试和功能测试怎么一起实现？
    * 白盒测试方法：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖
    * 语句覆盖每条语句至少执行一次。
    * 判定覆盖每个判定的每个分支至少执行一次。
    * 条件覆盖每个判定的每个条件应取到各种可能的值。
    * 判定/条件覆盖同时满足判定覆盖条件覆盖。
    * 条件组合覆盖每个判定中各条件的每一种组合至少出现一次。
    * 其实这些方法执行的过程，就把功能测试里面的功能点执行了一遍
  * 你对测试开发的理解是什么？
    * 除了功能测试之外，更注重自动化测试、测试工具的开发
  * 逻辑算法题：<br>
     丢了一个东西，总共有ABCD四个人，其中有一个人说了假话，3个人说了真话：<br>
     A：不是我偷的；    B：C偷的；    C：D偷的；    D：C撒谎了； 
     请问到底谁撒谎了，现在用程序来实现你说的过程？<br>
     ```python
    if __name__ == '__main__':
        murderers = ['A', 'B', 'C', 'D']
        for murderer in murderers:
            if (murderer != 'A') + (murderer == 'C') + (murderer == 'D') + (murderer != 'D') == 3:
                print(murderer)
     ```
   * linux查看与mysql相关的进程
     ps -ef|grep mysql 
   * TCP为什么是三次握手
     保证双方都可以接受并且传递消息
   * TCP实现可靠传输的方法
     * 确认号：ACK
     * 超时重传
     * TCP的连接管理：三次握手与四次挥手
     * 滑动窗口
     * 流量控制：设置滑动窗口的大小，控制流量
     * 拥塞控制
   * TCP的拥塞控制
     * 慢开始：当发送端开始发送数据时，如果立即将大量数据字节注入到网络，那么就有可能因为不清楚当前网络的负荷情况而引起网络阻塞。所以，最好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。
     * 拥塞避免：只要判断网络出现拥塞，就要把慢启动开始门限（ssthresh）设置为发送窗口的一半（>=2），cwnd设置为1，然后再使用慢启动算法，这样做的目的能迅速的减少网络当中的数据传输，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。
     * 快重传：当接收方收到一个失序的报文段后立刻发出重复确认
     * 快恢复：当发送方连续收到三个重复确认时，执行“乘法减小”算法，慢启动门限减半，为了预防网络发生阻塞
   * socket编程实现tcp的过程
   * https的原理
   * 套接字的好处
   * AVL树 特性
     * AVL树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
     * 在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树
   * 完全二叉树 有n个结点，求深度
     * 「log2n」+1
   * 链表的特点
     可以从增删改查来说
   * 快排
   * 二叉树的层序遍历--OK
   * 用代码模拟洗牌过程，及如何测试
     * 稍后补充：52张牌，4中花色，每种花色从1-12，用k%4 表示数字；K//4 表示花色
     * random模块
   * 写linux常用命令
   * http协议有几种请求类型
   * 栈和队列的区别及其使用场景
   * 项目中用到的测试方法
   * 索引的优缺点
     * 优点： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；可以加快数据的检索速度，这也是创建索引的最主要的原因；可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义；在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
     * 缺点：建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加；索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大；当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
   * 从输入URL后发生了什么
     * 
   * char和vchar区别
     * char的长度是不可变的，而varchar的长度是可变的；
     * 定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的，
     * char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。
     * char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节。
   * 会性能测试吗？性能测试需要哪些工具？用过吗
   * 写一下QQ登录的测试用例
     * 界面
     * 快捷键
     * 输入框（输入空/非空、是否支持复制粘贴移动、密文的显示）
     * 验证码
     * 网络
     * 安全：登录次数
   * adb查看手机里的进程
       adb shell 进入手机linux系统后，执行ps就能显示手机里所有正在运行的进程
   * adb安装应用程序（因为实习接触android手机所以提了下会adb，一般不会考adb的）
   * 像我们这种视频聊天用了什么网络协议？
   * 网络的基本分层有哪些？
     * OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
     * 五层模型：物理层、数据链路层、网络层、传输层、应用层
   * 客户端发一个请求到服务端拿到一个结果，每一层都做了什么？
   
   * 你知道selenium工具做什么的吗
   * 对微信app的聊天界面进行测试（包括ios及安卓端），仅测试文本框（用于键盘输入）以及聊天记录的页面，仅测试文字发送，仅测试一对一聊天，请从业务、技术、经验等方面，列出你的测试点。
   * 从聊天历史记录页面有什么可以扩展的测试点。
   * 如果安卓系统经常出现黑屏，可能是什么原因。
     * 外部原因：摔过、潮湿环境中、电池使用不当
     * 内部软件原因：内存占用过度、软件冲突
   * 安卓界面的渲染你了解吗？比如什么时候会丢帧之类的。
   * 在Linux系统下怎么查看进程状态？
