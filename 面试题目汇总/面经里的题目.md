## 字节跳动（后端）
* 验证密码，长度要求在[6,20]之间，大写字母 小写字母 数字 其他至少要三种，不能有长度超过2的重复子串
```python
def CheckLegth(pwd):
    size = len(pwd)
    if size < 6 or size > 20:
        return False
    return True
def CheckTypes(pwd):
    types = [0, 0, 0, 0]
    for i in range(len(pwd)):
        if pwd[i].isdigit():
            types[0] = 1
        elif pwd[i].isupper():
            types[1] = 1
        elif pwd[i].islower():
            types[2] = 1
        else:
            types[3] = 1
    if sum(types) < 3:
        return False
    return True
def ChcekSubString(pwd):
    size = len(pwd)
    for i in range(size-2):
        for j in range(i + 3, size):
            if pwd[i:j] in pwd[j:]:
                return False
    return True
if __name__ == '__main__':
    pwd = input()
    if CheckLegth(pwd) and CheckTypes(pwd) and ChcekSubString(pwd):
        print('OK')
    else:
        print('NG')
```
* [55. Jump Game](https://leetcode.com/problems/jump-game/)
```python
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        size = len(nums)
        isarrive = [False for i in range(size)]
        isarrive[0] = True
        for i in range(1, size):
            for j in range(i):
                if isarrive[j] == True and nums[j] >= i-j:
                    isarrive[i] = True
        return isarrive[size-1]
```
超时解法

```python
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        size = len(nums)
        reach = 0
        for i in range(size):
            if i > reach: # reach小于当前位置i，表示到不了当前位置
                return False
            reach = max(reach, i + nums[i]) 
            if reach >= size - 1:
                return True
        return False
```
贪心算法：i表示当前坐标，reach表示可以到达的最远地方；只要reach大于最后一个位置的时候就可以，不是要求正好相等

*  捡金币，n * n的格，-1表示障碍，该格不能走，0表示可以通过，1表示有一个金币，grid的值只有这三种，从左上到右下，只能向右或向下，到最后一格，
然后再从右下到左上，只能向左或向上，求能够获得的最大金币数。第一次走过的格子，捡了金币后应该置为0，该格还可以继续走，(0，0)和(-1，-1)这两格不会是-1。
```python
# -*- coding:utf-8 -*-

# 验证密码，长度要求，大写字母 小写字母 数字 其他至少要三种，不能有长度超过2的重复子串

def PickGold(grid):
    size = len(grid)
    # dp[i][j]表示[i,j]格子可以获得的最大金币数
    dp = [[0 for _ in range(size)] for _ in range(size)]
    dp[0][0] = grid[0][0]
    grid[0][0] = 0

    # 第一行只能向右走
    for j in range(1, size):
        if grid[0][j] == -1: # 有一个格子为-1，后面的都不能走了，直接跳出循环
            break
        else:
            dp[0][j] = dp[0][j-1] + grid[0][j]
            grid[0][j-1] = 0  # 捡完后置0

    # 第一列只能向下走
    for i in range(1, size):
        if grid[i][0] == -1:
            break
        else:
            dp[i][0] = dp[i-1][0] + grid[i][0]
            grid[i-1][0] = 0

    for i in range(1, size):
        for j in range(1, size):
            if grid[i][j] == -1:
                continue
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]
                # 判断是由哪个格子过来的，将格子金币数置0
                if dp[i][j] == dp[i][j-1] and grid[i][j-1] != -1:
                    grid[i][j-1] = 0
                if dp[i][j] == dp[i-1][j] and grid[i-1][j] != -1:
                    grid[i][j] = 0

    return grid, dp[size-1][size-1]


if __name__ == '__main__':
    grid = [[1,2,3],[4,5,6],[7,8,9]]
    size = len(grid)
    # 左上到右下
    grid, total1 = PickGold(grid)

    # 翻转grid
    newgrid = [[0 for _ in range(size)] for _ in range(size)]
    for i in range(size):
        for j in range(size):
            newgrid[i][j] = grid[size-1-i][size-1-j]
    # 右下到左上
    grid, total2 = PickGold(newgrid)
    
    total = total1 + total2
    print(total)
```
待补充
