# 秋招测试岗
## 笔试：12个选择+3道编程，时间120min
* 输入一个无序数组，求TopK大数。按照从小到大的顺序输出这K个数
```python
# -*- coding:utf-8 -*-
def ModifyMinHeap(heap, root):  # 修改
    size = len(heap)
    left = 2 * root + 1
    right = 2 * root + 2
    smallest = root
    if left < size and heap[left] < heap[smallest]:
        smallest = left
    if right < size and heap[right] < heap[smallest]:
        smallest = right
    heap[root], heap[smallest] = heap[smallest], heap[root]
    if smallest != root:
        ModifyMinHeap(heap, smallest)
def BulidMinHeap(heap): # 构建
    for i in range(len(heap) // 2 - 1, -1, -1):
        ModifyMinHeap(heap, i)
def TopKMinest(arrs, k):
    if not arrs or k < 1 or k > len(arrs):
        return []
    heap = arrs[:k]
    BulidMinHeap(heap)
    for i in range(k, len(arrs)):
        if arrs[i] > heap[0]:
            heap[0], arrs[i] = arrs[i], heap[0]
            ModifyMinHeap(heap, 0)
    return sorted(heap)

if __name__ == '__main__':
    arrs = [9, 8, 3, 4, 5, 1]
    k = 4
    print(TopKMinest(arrs, k))
    
```
同剑指offer中“最小的K个数”，此处要求最大的K个数，需要建立一个容量为K的最小堆，堆顶元素存储当前k个数中的最小数。遍历数组，从第K+1个数与堆顶元素比较，如果比其小，说明它比容器里面的K个数都小，直接舍弃；如果比堆顶元素大，需要加进来，舍弃堆顶元素。时间复杂度为O(nlogK)

* 
