
<!-- GFM-TOC -->
* <a href="#SQL 语法">SQL 语法</a>
* <a href="#事务">事务</a>
* <a href="#存储过程">存储过程</a>
* <a href="#游标">游标</a>
* <a href="#范式">范式</a>
* <a href="#视图">视图</a>
* <a href="#索引">索引</a>
* <a href="#锁">锁</a>
* <a href="#键">键</a>
* <a href="#SQL约束">SQL约束</a>
* <a href="#MYSQL存储引擎">MYSQL存储引擎</a>
* <a href="#不同数据库的区别">不同数据库的区别</a>
* <a href="#参考资料">参考资料</a>
<!-- GFM-TOC -->

# SQL 语法：
![image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/SQl%E8%AF%AD%E5%8F%A5%E4%BD%8E%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9.png)

# 事务(常见的例子如银行转帐)
* 定义：一个Session中所有进行的操作，要么全做，要么全都不做。
* 特性：ACID
  * 原子性（Atomicity）：事务包含的所有操作要么全部成功，要么全部失败回滚
  * 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态
  * 隔离性（Isolation）：事务与事务之间的执行，互不干扰
  * 持久性（Durability）：一个事务一旦被提交了，则对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作
* 语法：
  * BEGIN TRAN transaction_name 
  * COMMIT TRAN transaction_name
  * ROLLBACK TRAN transaction_name
  * SAVEPOINT savepoint_name：在事务内部创建一系列可以 ROLLBACK 的还原点，这些还原点只能在事务内部创建
  * RELEASE SAVEPOINT savepoint_name：删除创建的保存点
# 存储过程

# 游标

# 范式
* 范式越高，数据的冗余度越小。没有冗余的数据库设计是可以做到的，但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据
* 范式级别：实际应用，到3NF或者BCNF就可以了
  * 1NF：属性不可再分
  * 2NF：消除非主属性对码的部分函数依赖
  * 3NF：消除非主属性对码的传递函数依赖
  * BCNF：消除主属性之间的函数依赖
  * 4NF：消除表中的多值依赖
  * 5NF：消除不是由候选码所蕴含的连接依赖
* 当时学数据库的时候，在知乎上看明白的一篇[文章](https://www.zhihu.com/question/24696366)，介绍的很清楚

# 视图
* 定义：从一个或几个基本表中根据用户需要而做成一个虚表，视图是虚表,它在存储时只存储视图的定义,而没有存储对应的数据
* 作用：　
  * 分割数据，通过select和where来定义视图，从而可以分割数据基表中某些对于用户不关心的数据，使用户把注意力集中到所关心的数据列
  * 为数据提供一定的逻辑独立性
  * 安全，视图能像基本表一样授予或撤消访问许可权
  * 间接对表进行更新，视图的更新就是表的更新
* 语法：
  * 创建视图：CREATE VIEW view_name AS SELECT ……
  * 修改视图：ALTER VIEW view_name AS SELECT 
  * 删除视图：DROP VIEW view_name  
  
# 索引
* 建立索引的目的：
  * 唯一性索引，保证数据库中数据的唯一性
  * 加快数据检索速度
  * 加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
  * 在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。
  * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
* 创建索引不利的地方：
  * 创建索引和维护索引需要消耗时间
  * 索引需要占物理空间，如果要建立聚簇索引，那么需要额外空间会更大
  * 当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
* 什么列上需要建立索引？
  * 列为主键，强制该列的唯一性
  * 经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
  * 经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
  * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
  * 在经常使用在where子句中的列上面创建索引，加快条件的判断速度
* 什么列上不需要建立索引？
  * 不经常使用的列
  * 只有很少数据值的列（比如性别）
  * 对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
  * 经常需要修改的列
* 语法：
  * 单列索引：CREATE INDEX index_name ON table_name (column_name);
  * 唯一索引：CREATE UNIQUE INDEX index_name ON table_name (column_name);
  * 聚簇索引：CREATE INDEX index_name ON table_name (column1, column2);
  * 隐式索引：隐式索引由数据库服务器在创建某些对象的时候自动生成。例如，对于主键约束和唯一约束，数据库服务器就会自动创建索引。
  * 删除索引：DROP INDEX index_name
* 聚集索引与非聚集索引区别：
  * 聚集索引：索引的排列顺序和表中记录的排列顺序一致，查询快，修改慢
  * 非聚集索引（如字典中按照偏旁查字）：非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构
  * 根本区别：索引与表记录的顺序是否排列一致

# 封锁
* 并发操作带来的数据不一致问题：
  * 丢失修改：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改丢失；
  * 不可重复读：指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果；
  * 读脏数据：指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据为“脏”数据;
* 解决不一致问题的方法——封锁：
  * 定义：事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象；
  * 类型：
    * 排它锁（x锁），又称写锁：若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A ，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。
    * 共享锁 (S锁），又称读锁：若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A ，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁
  * 活锁与死锁：
    * 活锁：当一系列封锁不按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁；解决方法是：先来先服务
    * 死锁：两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。产生的必要条件：互斥/占有并等待/不剥夺/环路等待；解决方法：预防（破坏产生死锁的必要条件）/诊断（检测是否有死锁产生）/解除（撤销掉代价最小的事务，解除环路）   
* 并发控制：
  * 并行序列可串行化：并行序列的执行结果和串行的执行结果相同，则称为～
  * 一次封锁法：事务开始时，即一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。
  * 两段锁协议：整个事务分为两个阶段，前一个阶段为加锁（扩张阶段），后一个阶段为解锁（收缩阶段）。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。

# SQL约束
* 
# MYSQL存储引擎
* InnoDB

* MyISAM
* MEMORY

# 其他概念性质的东西

# 不同数据库的区别



# [参考资料](https://juejin.im/post/5a9ca0d6518825555c1d1acd)
