
<!-- GFM-TOC -->
* <a href="#SQL 语法">SQL 语法</a>
* <a href="#事务">事务</a>
* <a href="#存储过程">存储过程</a>
* <a href="#游标">游标</a>
* <a href="#范式">范式</a>
* <a href="#视图">视图</a>
* <a href="#索引">索引</a>
* <a href="#锁">锁</a>
* <a href="#键">键</a>
* <a href="#SQL约束">SQL约束</a>
* <a href="#MYSQL存储引擎">MYSQL存储引擎</a>
* <a href="#不同数据库的区别">不同数据库的区别</a>
* <a href="#参考资料">参考资料</a>
<!-- GFM-TOC -->

# SQL 语法：
![image](https://github.com/MissAquarius/ForJobHunting/blob/master/image/SQl%E8%AF%AD%E5%8F%A5%E4%BD%8E%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9.png)

# 事务
* 定义：一个Session中所有进行的操作，要么全做，要么全都不做。
* 特性：ACID
  * 原子性（Atomicity）：事务包含的所有操作要么全部成功，要么全部失败回滚
  * 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态
  * 隔离性（Isolation）：事务与事务之间的执行，互不干扰
  * 持久性（Durability）：一个事务一旦被提交了，则对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作
* 定义方法：

# 存储过程

# 游标

# 范式
* 1NF：属性不可再分
* 2NF：消除非主属性对码的部分函数依赖
* 3NF：消除非主属性对码的传递函数依赖
* 4NF：消除主属性之间的函数依赖
* 5NF：
* BCNF：

# 视图

# 索引
* 建立索引的目的：
  * 唯一性索引，保证数据库中数据的唯一性
  * 加快数据检索速度
  * 加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
  * 在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。
  * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
* 创建索引不利的地方：
  * 创建索引和维护索引需要消耗时间
  * 索引需要占物理空间，如果要建立聚簇索引，那么需要额外空间会更大
  * 当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
* 什么列上需要建立索引？
  * 列为主键，强制该列的唯一性
  * 经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
  * 经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
  * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
  * 在经常使用在where子句中的列上面创建索引，加快条件的判断速度
* 什么列上不需要建立索引？
  * 不经常使用的列
  * 只有很少数据值的列（比如性别）
  * 对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
  * 经常需要修改的列
* 语法：
  * 单列索引：CREATE INDEX index_name ON table_name (column_name);
  * 唯一索引：CREATE UNIQUE INDEX index_name ON table_name (column_name);
  * 聚簇索引：CREATE INDEX index_name ON table_name (column1, column2);
  * 隐式索引：隐式索引由数据库服务器在创建某些对象的时候自动生成。例如，对于主键约束和唯一约束，数据库服务器就会自动创建索引。
  * 删除索引：DROP INDEX index_name
# 封锁
* 并发操作带来的数据不一致问题：
  * 丢失修改：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改丢失；
  * 不可重复读：指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果；
  * 读脏数据：指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据为“脏”数据;
* 解决不一致问题的方法——封锁：
  * 定义：事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象；
  * 类型：
    * 排它锁（x锁），又称写锁：若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A ，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。
    * 共享锁 (S锁），又称读锁：若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A ，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁
 * 活锁与死锁：
   * 活锁：当一系列封锁不按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁；解决方法是：先来先服务
   * 死锁：
 * 两段锁协议：
   
# 键

# SQL约束

# MYSQL存储引擎

# 不同数据库的区别



# [参考资料](https://juejin.im/post/5a9ca0d6518825555c1d1acd)
